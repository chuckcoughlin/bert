/**
 * Copyright 2019. Charles Coughlin. All Rights Reserved.
 *                 MIT License.
 *
 */
package bert.server.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import bert.server.message.SequentialMessage;
import bert.server.message.TimedMessage;
import bert.share.controller.Controller;
import bert.share.message.MessageBottle;
import bert.share.message.MessageHandler;

/**
 *  A timer controller accepts a RequestBottle and submits it to the parent
 *  Dispatcher on a clocked basis. The initial implementation handles only a
 *  single request.
 */
public class InternalController implements Controller  {
	protected static final String CLSS = "InternalController";
	private Logger LOGGER = Logger.getLogger(CLSS);
	private final MessageHandler dispatcher;
	private final TimedQueue timedQueue;
	private final Map<QueueName,SequentialQueue> sequentialQueues;
	
	
	/**
	 * Constructor: Create all the necessary queues
	 * @param launcher the launcher parent process
	 */
	public InternalController(MessageHandler launcher) {
		this.dispatcher = launcher;
		this.timedQueue = new TimedQueue(dispatcher);
		this.sequentialQueues = new HashMap<>();
		sequentialQueues.put(QueueName.GLOBAL, new SequentialQueue());
		sequentialQueues.put(QueueName.HEAD, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_LEG, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_LEG, new SequentialQueue());
	}
	
	/**
	 * All requests are generated by the dispatcher or dispatcher's solver.
	 * The class determines how we handle them.
	 */
	@Override
	public synchronized void receiveRequest(MessageBottle request) {
		if( request instanceof SequentialMessage) {
			SequentialMessage msg = (SequentialMessage)request;
			SequentialQueue queue = sequentialQueues.get(msg.getQueue());
			queue.addLast(msg);
			if( !queue.isInProgress()) {
				queue.setInProgress(true);
				msg = queue.removeFirst(); 
				timedQueue.addMessage(msg);  // Just in case there's a required delay
			}
		}
		else if( request instanceof TimedMessage) {
			TimedMessage msg = (TimedMessage)request;
			timedQueue.addMessage(msg);
		}
		else {
			LOGGER.warning(String.format("%s: receiveRequest received unhandlable request (%s)",CLSS,request.fetchRequestType().name()));
		}

	}
	/**
	 * The dispatcher has received a response to one of our requests and has
	 * forwarded it here.
	 */
	@Override
	public synchronized void receiveResponse(MessageBottle response) {
		if( response instanceof SequentialMessage) {
			SequentialMessage msg = (SequentialMessage)response;
			SequentialQueue queue = sequentialQueues.get(msg.getQueue());
			if( queue.isEmpty() ) {
				queue.setInProgress(false);
			}
			else {
				msg = queue.removeFirst(); 
				timedQueue.addMessage(msg);  // Just in case there's a required delay
			}
		}
		else if( response instanceof TimedMessage) {
			TimedMessage msg = (TimedMessage)response;
			if( msg.shouldRepeat() ) {
				long now = System.nanoTime()/1000000;   // Work in milliseconds
				msg.setExecutionTime(now+msg.getRepeatInterval());
				timedQueue.addMessage(msg);
			}
		}
		else {
			LOGGER.warning(String.format("%s: receiveResponse received unhandlable response (%s)",CLSS,response.fetchRequestType().name()));
		}
	}
	
	@Override
	public void start() {
		timedQueue.start();
	}
	@Override
	public void stop() {
		timedQueue.stop();
	}
}
