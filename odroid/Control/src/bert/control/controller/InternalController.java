/**
 * Copyright 2019. Charles Coughlin. All Rights Reserved.
 *                 MIT License.
 *
 */
package bert.control.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import bert.control.message.InternalMessageHolder;
import bert.share.message.HandlerType;
import bert.share.message.MessageBottle;
import bert.share.message.MessageHandler;

/**
 *  A timer controller accepts a RequestBottle and submits it to the parent
 *  Dispatcher on a clocked basis. The initial implementation handles only a
 *  single request.
 */
public class InternalController {
	protected static final String CLSS = "InternalController";
	private Logger LOGGER = Logger.getLogger(CLSS);
	private final MessageHandler dispatcher;
	private final TimedQueue timedQueue;
	private final Map<QueueName,SequentialQueue> sequentialQueues;
	private final Map<Long,InternalMessageHolder> pendingMessages;
	
	/**
	 * Constructor: Create all the necessary queues
	 * @param launcher the launcher parent process
	 */
	public InternalController(MessageHandler launcher) {
		this.dispatcher = launcher;
		this.timedQueue = new TimedQueue(this);
		this.sequentialQueues = new HashMap<>();
		this.pendingMessages  = new HashMap<>();
		sequentialQueues.put(QueueName.GLOBAL, new SequentialQueue());
		sequentialQueues.put(QueueName.HEAD, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_LEG, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_LEG, new SequentialQueue());
	}
	
	/**
	 * All requests to the InternalController are generated by the dispatcher or dispatcher's solver.
	 * This class determines how we handle them. If there is no queue specified
	 * then the message is placed directly on the timer queue.
	 * @param request incoming message holder
	 */
	public synchronized void receiveRequest(InternalMessageHolder holder) {
		long now = System.nanoTime()/1000000; 
		holder.setExecutionTime(now+holder.getDelay());
		
		QueueName qn = holder.getQueue();
		SequentialQueue queue = null;
		if( qn!=null ) queue = sequentialQueues.get(qn);
		if( queue!=null) {
			LOGGER.info(String.format("%s.receiveRequest %s on %s (%s)",CLSS,holder.getMessage().fetchRequestType().name(),
						holder.getQueue().name(),(queue.isInProgress()?"IN PROGRESS":"IDLE")));
			queue.addLast(holder);
			if( !queue.isInProgress()) {
				holder = queue.removeFirst();
				queue.setInProgress(true);
				sendToTimerQueue(queue,holder);  // Just in case there's a required delay
			}
		}
		// Place directly on the timer queue
		else {
			sendToTimerQueue(null,holder);
		}
	}
	
	/**
	 * The dispatcher has received a response to one of our requests and has
	 * forwarded it here. Possible dispositions:
	 *     1) If message was from a queue, then we trigger processing of the next message on the queue, if any
	 *     2) If the message was marked for repeating, then place it on the timer queue
	 *     3) Discard the message,
	 */
	public void receiveResponse(MessageBottle msg) {
		InternalMessageHolder holder = pendingMessages.get(msg.getId());
		if( holder!=null ) {
			pendingMessages.remove(msg.getId());
			// Reinstate the original source in the message so the dispatcher can route appropriately	
			holder.reinstateOriginalSource();
			
			//LOGGER.info(String.format("%s.receiveResponse(%d) %s",CLSS,holder.getMessage().getId(),
			//		holder.getMessage().fetchRequestType().name()));
			QueueName qn = holder.getQueue();
			SequentialQueue queue = null;
			if( qn!=null ) queue = sequentialQueues.get(qn);
			if( queue!=null ) {
				if( queue.isEmpty() ) {
					LOGGER.info(String.format("%s.receiveResponse(%d) %s on %s (empty)",CLSS,holder.getMessage().getId(),
							holder.getMessage().fetchRequestType().name(),qn.name()));
					queue.setInProgress(false);
				}
				else {
					queue.setInProgress(true);
					LOGGER.info(String.format("%s.receiveResponse(%d) %s on %s (%d queued)",CLSS,holder.getMessage().getId(),
							holder.getMessage().fetchRequestType().name(),qn.name(),queue.size()));
					holder = queue.removeFirst(); 	
					sendToTimerQueue(queue,holder);  // Just in case there's a required delay
				}
			}
			// The response is not associated with a queue. The only consideration
			// now is if it is repeated. Otherwise we do nothing.
			else  {
				if( holder.shouldRepeat() ) {
					long now = System.nanoTime()/1000000;   // Work in milliseconds
					holder.setExecutionTime(now+holder.getRepeatInterval());
					sendToTimerQueue(null,holder);
				}
			}
			dispatcher.handleResponse(msg);  // Will reply to the original source
		}
		else {
			LOGGER.info(String.format("%s.receiveResponse(%d) %s: not on pending queue for %s",CLSS,msg.getId(),msg.fetchRequestType().name(),msg.fetchSource()));
		}
	}

	/**
	 * Called by the timer queue once the message is ready to execute. Forward to the
	 * dispatcher for actual processing. Mark the source as INTERNAL so
	 * that the dispatcher knows to return the message here once processing is complete.
	 * @param holder
	 */
	public synchronized void dispatch(InternalMessageHolder holder) {
		holder.getMessage().assignSource(HandlerType.INTERNAL.name());
		dispatcher.handleRequest(holder.getMessage());
	}
	
	public void start() {
		timedQueue.start();
	}

	public void stop() {
		timedQueue.stop();
	}
	
	/**
	 *  As far as the sequential queue is concerned, a message is pending
	 *  from the time it is placed on the timer queue until it returns
	 * as a response from the Dispatcher
	 * @param queue queue from which the message originated.
	 * @param holder container for the message to be sent
	 */
	private void sendToTimerQueue(SequentialQueue queue,InternalMessageHolder holder) {
		if( queue!=null ) {
			pendingMessages.put(holder.getMessage().getId(),holder);
			// LOGGER.info(String.format("%s.sendToTimerQueue: %d from %s",CLSS,holder.getMessage().getId(),holder.getQueue().name()));
			queue.setInProgress(true);
		}
		timedQueue.addMessage(holder);
	}
}
