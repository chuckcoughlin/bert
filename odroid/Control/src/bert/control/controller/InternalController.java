/**
 * Copyright 2019. Charles Coughlin. All Rights Reserved.
 *                 MIT License.
 *
 */
package bert.control.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import bert.control.message.InternalMessage;
import bert.share.controller.Controller;
import bert.share.message.MessageBottle;
import bert.share.message.MessageHandler;

/**
 *  A timer controller accepts a RequestBottle and submits it to the parent
 *  Dispatcher on a clocked basis. The initial implementation handles only a
 *  single request.
 */
public class InternalController implements Controller  {
	protected static final String CLSS = "InternalController";
	private Logger LOGGER = Logger.getLogger(CLSS);
	private final MessageHandler dispatcher;
	private final TimedQueue timedQueue;
	private final Map<QueueName,SequentialQueue> sequentialQueues;
	
	
	/**
	 * Constructor: Create all the necessary queues
	 * @param launcher the launcher parent process
	 */
	public InternalController(MessageHandler launcher) {
		this.dispatcher = launcher;
		this.timedQueue = new TimedQueue(dispatcher);
		this.sequentialQueues = new HashMap<>();
		sequentialQueues.put(QueueName.GLOBAL, new SequentialQueue());
		sequentialQueues.put(QueueName.HEAD, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_LEG, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_LEG, new SequentialQueue());
	}
	
	/**
	 * All InternalMessage requests are generated by the dispatcher or dispatcher's solver.
	 * This class determines how we handle them. If there is no queue specified
	 * then the message is placed directly on the timer queue.
	 * @param request incoming message
	 */
	@Override
	public synchronized void receiveRequest(MessageBottle request) {
		if( request instanceof InternalMessage) {
			InternalMessage msg = (InternalMessage)request;
			SequentialQueue queue = sequentialQueues.get(msg.getQueue());
			if( queue!=null) {
				LOGGER.info(String.format("%s: receiveRequest received sequential request (%s) queue %s",CLSS,request.fetchRequestType().name(),
						(queue.isInProgress()?"IN PROGRESS":"IDLE")));
				queue.addLast(msg);
				if( !queue.isInProgress()) {
					queue.setInProgress(true);
					msg = queue.removeFirst(); 
					timedQueue.addMessage(msg);  // Just in case there's a required delay
				}
			}
			else  {
				long now = System.nanoTime()/1000000; 
				msg.setExecutionTime(now+msg.getDelay());
				timedQueue.addMessage(msg);
			}
		}
		else {
			LOGGER.warning(String.format("%s: receiveRequest only internal messages are handled, got (%s)",CLSS,request.fetchRequestType().name()));
		}

	}
	/**
	 * The dispatcher has received a response to one of our requests and has
	 * forwarded it here. Possible dispositions:
	 *     1) If message was from a queue, then we trigger processing of the next message on the queue, if any
	 *     2) If the message was marked for repeating, then place it on the timer queue
	 *     3) Discard the message,
	 */
	@Override
	public synchronized void receiveResponse(MessageBottle response) {
		if( response instanceof InternalMessage) {
			InternalMessage msg = (InternalMessage)response;
			SequentialQueue queue = sequentialQueues.get(msg.getQueue());
			if( queue!=null ) {
				if( queue.isEmpty() ) {
					queue.setInProgress(false);
					LOGGER.info(String.format("%s: receiveResponse received %s (%s) queue now IDLE",CLSS,response.fetchRequestType().name(),
							msg.getQueue()));
				}
				else {
					queue.setInProgress(true);
					LOGGER.info(String.format("%s: receiveResponse received sequential response %s (%s) queue IN PROGRESS",CLSS,
							response.fetchRequestType().name(),msg.getQueue()));
					msg = queue.removeFirst(); 
					timedQueue.addMessage(msg);  // Just in case there's a required delay
				}
				
			}
			// The response is not associated with a queue. The only consideration
			// now is if it is repeated. Otherwise we do nothing.
			else  {
				if( msg.shouldRepeat() ) {
					long now = System.nanoTime()/1000000;   // Work in milliseconds
					msg.setExecutionTime(now+msg.getRepeatInterval());
					timedQueue.addMessage(msg);
				}
			}
		}
		else {
			LOGGER.warning(String.format("%s: receiveResponse received unhandlable response (%s)",CLSS,response.fetchRequestType().name()));
		}
	}

	@Override
	public void start() {
		timedQueue.start();
	}
	@Override
	public void stop() {
		timedQueue.stop();
	}
}
