/**
 * Copyright 2019. Charles Coughlin. All Rights Reserved.
 *                 MIT License.
 *
 */
package bert.control.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import bert.control.message.InternalMessageHolder;
import bert.share.message.MessageBottle;
import bert.share.message.MessageHandler;

/**
 *  A timer controller accepts a RequestBottle and submits it to the parent
 *  Dispatcher on a clocked basis. The initial implementation handles only a
 *  single request.
 */
public class InternalController {
	protected static final String CLSS = "InternalController";
	private Logger LOGGER = Logger.getLogger(CLSS);
	private final MessageHandler dispatcher;
	private final TimedQueue timedQueue;
	private final Map<QueueName,SequentialQueue> sequentialQueues;
	private final Map<Long,InternalMessageHolder> pendingMessages;
	
	/**
	 * Constructor: Create all the necessary queues
	 * @param launcher the launcher parent process
	 */
	public InternalController(MessageHandler launcher) {
		this.dispatcher = launcher;
		this.timedQueue = new TimedQueue(this);
		this.sequentialQueues = new HashMap<>();
		this.pendingMessages  = new HashMap<>();
		sequentialQueues.put(QueueName.GLOBAL, new SequentialQueue());
		sequentialQueues.put(QueueName.HEAD, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.LEFT_LEG, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_ARM, new SequentialQueue());
		sequentialQueues.put(QueueName.RIGHT_LEG, new SequentialQueue());
	}
	
	/**
	 * All requests to the InternalController are generated by the dispatcher or dispatcher's solver.
	 * This class determines how we handle them. If there is no queue specified
	 * then the message is placed directly on the timer queue.
	 * @param request incoming message holder
	 */
	public synchronized void receiveRequest(InternalMessageHolder holder) {
		long now = System.nanoTime()/1000000; 
		holder.setExecutionTime(now+holder.getDelay());
		
		QueueName qn = holder.getQueue();
		SequentialQueue queue = null;
		if( qn!=null ) queue = sequentialQueues.get(qn);
		if( queue!=null) {
			LOGGER.info(String.format("%s.receiveRequest %s on %s (%s)",CLSS,holder.getMessage().fetchRequestType().name(),
						holder.getQueue().name(),(queue.isInProgress()?"IN PROGRESS":"IDLE")));
			
			queue.addLast(holder);
			if( !queue.isInProgress()) {
				holder = queue.removeFirst();
				queue.setInProgress(true);
				sendToTimerQueue(holder);  // Just in case there's a required delay
			}
		}
		// Place directly on the timer queue
		else {
			sendToTimerQueue(holder);
		}
	}
	
	/**
	 * The dispatcher has received a response to one of our requests and has
	 * forwarded it here. Possible dispositions:
	 *     1) If message was from a queue, then we trigger processing of the next message on the queue, if any
	 *     2) If the message was marked for repeating, then place it on the timer queue
	 *     3) Discard the message,
	 */
	public synchronized void receiveResponse(MessageBottle msg) {
		InternalMessageHolder holder = pendingMessages.get(msg.getId());
		QueueName qn = holder.getQueue();
		SequentialQueue queue = null;
		if( qn!=null ) queue = sequentialQueues.get(qn);
		if( queue!=null ) {
			if( queue.isEmpty() ) {
				queue.setInProgress(false);
				LOGGER.info(String.format("%s.receiveResponse %s on %s (empty)",CLSS,holder.getMessage().fetchRequestType().name()));
			}
			else {
				queue.setInProgress(true);
				LOGGER.info(String.format("%s.receiveResponse %s on %s (%d queued)",CLSS,holder.getMessage().fetchRequestType().name(),
						queue.size()));
				holder = queue.removeFirst(); 
				sendToTimerQueue(holder);  // Just in case there's a required delay
			}

		}
		// The response is not associated with a queue. The only consideration
		// now is if it is repeated. Otherwise we do nothing.
		else  {
			if( holder.shouldRepeat() ) {
				long now = System.nanoTime()/1000000;   // Work in milliseconds
				holder.setExecutionTime(now+holder.getRepeatInterval());
				sendToTimerQueue(holder);
			}
		}
		// No what we're done with the response, re-instate its original source and let the dispatcher take care of it
		pendingMessages.remove(msg.getId());
		holder.reinstateOriginalSource();
		dispatcher.handleResponse(msg);  // Will reply to the original source
	}

	/**
	 * Called by the timer queue when the message is ready to execute. If this message is from a
	 * queue snd off the next in line.
	 * @param holder
	 */
	public synchronized void dispatch(InternalMessageHolder holder) {
		
		QueueName qn = holder.getQueue();
		SequentialQueue queue = null;
		if( qn!=null ) queue = sequentialQueues.get(qn);
		if( queue!=null ) {
			holder = queue.removeFirst();
			if( holder!=null ) timedQueue.addMessage(holder);
			else queue.setInProgress(false);
		}
		dispatcher.handleRequest(holder.getMessage());
	}
	
	public void start() {
		timedQueue.start();
	}

	public void stop() {
		timedQueue.stop();
	}
	
	private void sendToTimerQueue(InternalMessageHolder holder) {
		pendingMessages.put(holder.getMessage().getId(),holder);
		timedQueue.addMessage(holder);
	}
}
