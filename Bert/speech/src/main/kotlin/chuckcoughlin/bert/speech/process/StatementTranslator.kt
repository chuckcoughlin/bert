/**
 * Copyright 2022-2024. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.speech.process

// The following are classes generated by the parser. @See SpeechSyntaxParser
import chuckcoughlin.bert.common.message.*
import chuckcoughlin.bert.common.model.*
import chuckcoughlin.bert.sql.db.Database
import chuckcoughlin.bert.syntax.SpeechSyntaxBaseVisitor
import chuckcoughlin.bert.syntax.SpeechSyntaxParser
import java.util.*
import java.util.logging.Logger

/**
 * This translator takes spoken lines of text and converts them into
 * "Message Bottles" (requests). Note that the "visit" methods all return null,
 * an indicator that there is no further traversing the parse tree.
 */
class StatementTranslator(bot: MessageBottle, val sharedDictionary: MutableMap<SharedKey, Any>) :
    SpeechSyntaxBaseVisitor<Any>() {
    private val bottle: MessageBottle
    private val messageTranslator: MessageTranslator

    // These do the actual translations. Text->RequestBottle.
    // NOTE: Any action, state or pose names require database access to fill in the details.c
    // ================================= Overridden Methods =====================================
    // 
    // How tall are you?
    override fun visitAttributeQuestion(ctx: SpeechSyntaxParser.AttributeQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        val attribute: String = ctx.Attribute().getText()
        if (attribute.equals("old", ignoreCase = true)) {
            bottle.metric =  MetricType.AGE
        }
        else if (attribute.equals("tall", ignoreCase = true)) {
            bottle.metric = MetricType.HEIGHT
        }
        else {
            val msg = String.format("I don't know what %s means", attribute)
            bottle.error = msg
        }
        return null
    }

    // What are the names of your joints
    override fun visitBodyPartListQuestion(ctx: SpeechSyntaxParser.BodyPartListQuestionContext): Any? {
        bottle.type = RequestType.LIST_NAMES
        // Indicate whether we want static or dynamic properties - by setting one or the other
        if( ctx.Appendages()!=null ) bottle.metric = MetricType.APPENDAGES
        if( ctx.Motors()!=null  )    bottle.metric = MetricType.JOINTS
        if( ctx.Limbs()!=null  )     bottle.metric = MetricType.LIMBS
        return null
    }

    // List values from the database
    // What are the names of your poses
    override fun visitDatabaseListQuestion(ctx: SpeechSyntaxParser.DatabaseListQuestionContext): Any? {
        bottle.type = RequestType.LIST_NAMES
        // Indicate whether we want static or dynamic properties - by setting one or the other
        if( ctx.Faces()!=null ) bottle.metric = MetricType.FACES
        if( ctx.Poses()!=null  )    bottle.metric = MetricType.POSES
        return null
    }

    // you are singing
    override fun visitDeclarePose1(ctx: SpeechSyntaxParser.DeclarePose1Context): Any? {
        val pose: String = visit(ctx.phrase()).toString()
        sharedDictionary[SharedKey.POSE] = pose
        bottle.type = RequestType.SAVE_POSE
        bottle.pose = pose
        bottle.text = messageTranslator.randomAcknowledgement()
        return null
    }

    // your pose is sitting
    override fun visitDeclarePose2(ctx: SpeechSyntaxParser.DeclarePose2Context): Any? {
        val pose: String = visit(ctx.phrase()).toString()
        sharedDictionary[SharedKey.POSE] = pose
        bottle.type = RequestType.SAVE_POSE
        bottle.pose = pose
        bottle.text = messageTranslator.randomAcknowledgement()
        return null
    }

    // save your pose,  save your pose as an alternate universe
    override fun visitDeclareNoNamePose(ctx: SpeechSyntaxParser.DeclareNoNamePoseContext): Any? {
        bottle.type = RequestType.SAVE_POSE
        if (ctx.phrase() != null) {
            val pose: String = visit(ctx.phrase()).toString()
            sharedDictionary[SharedKey.POSE] = pose
            bottle.pose = pose
        }
        bottle.text = messageTranslator.randomAcknowledgement()
        return null
    }
    // Delete a pose or user given the name
    //    forget Chuck
    override fun visitDeletePose(ctx: SpeechSyntaxParser.DeletePoseContext): Any? {
        bottle.type = RequestType.COMMAND
        val pose: String = ctx.NAME().getText()
        bottle.command = CommandType.FORGET
        if(pose.isBlank()) {
            val msg = String.format("an argument is required")
            bottle.error = msg
        }
        bottle.pose = pose
        return null
    }
    // Apply "freeze" or "relax" to: Joints, Limbs, or the entire robot. "hold" is the same as "freeze".
    // relax your left arm
    override fun visitEnableTorque(ctx: SpeechSyntaxParser.EnableTorqueContext): Any? {
        LOGGER.info(String.format("%s.visitEnableTorque: error=%s -", CLSS, bottle.error))
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        bottle.jointDynamicProperty = JointDynamicProperty.STATE
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        // If side was set previously, use it as default
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        // If both Limb() and Joint() are null, then we apply to the entire robot
        if (ctx.Freeze() != null || ctx.Relax() != null || ctx.Hold() != null) {
            if (ctx.Freeze() != null || ctx.Hold() != null) {
                bottle.value = BottleConstants.ON_VALUE
            }
            if (ctx.Relax() != null) {
                bottle.value = BottleConstants.OFF_VALUE
            }
            // No joint or limb implies the entire body
            var joint: Joint = Joint.NONE
            if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.JOINT) {
                joint = sharedDictionary[SharedKey.JOINT] as Joint
            }
            if (ctx.Joint() != null) {
                joint = determineJoint(ctx.Joint().getText(), axis, side)
            }
            if (!joint.equals(Joint.NONE)) {

                bottle.joint= joint
                if (ctx.Freeze() != null || ctx.Hold() != null) {
                    bottle.addJointValue(joint, JointDynamicProperty.STATE, BottleConstants.ON_VALUE)
                }
                else {
                    bottle.addJointValue(joint, JointDynamicProperty.STATE,BottleConstants.OFF_VALUE)
                }
                sharedDictionary[SharedKey.JOINT] = joint
                sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            }
            else {
                var limb: Limb = Limb.NONE
                if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.LIMB) {
                    limb = sharedDictionary[SharedKey.LIMB] as Limb
                }
                if (ctx.Limb() != null) {
                    limb = determineLimb(ctx.Limb().getText(), side)
                }
                if( !limb.equals(Limb.NONE) ) {
                    bottle.type = RequestType.SET_LIMB_PROPERTY
                    bottle.limb = limb
                    if (ctx.Freeze() != null || ctx.Hold() != null) {
                        bottle.addJointValue(Joint.NONE, JointDynamicProperty.STATE, BottleConstants.ON_VALUE)
                    }
                    else {
                        bottle.addJointValue(Joint.NONE, JointDynamicProperty.STATE,BottleConstants.OFF_VALUE)
                    }
                    sharedDictionary[SharedKey.LIMB] = limb
                    sharedDictionary[SharedKey.IT] = SharedKey.LIMB
                }

            }
        }
        return null
    }

    // Handle a (possible) multi-word command to take a pose. However we make an initial check for "well-known"
    // commands.
    // carry the torch, go limp.
    override fun visitHandleArbitraryCommand(ctx: SpeechSyntaxParser.HandleArbitraryCommandContext): Any? {
        LOGGER.info(String.format("%s.visitHandleArbitraryCommand: LAST RESORT error=%s -", CLSS, bottle.error))
        if (ctx.phrase() != null) {
            val phrase: String = visit(ctx.phrase()).toString()
            // First handle "well-known" commands
            if (!determineCommandFromPhrase(phrase)) {   // Configures bottle
                // Next check to see if this is a pose
                if (Database.poseExists(phrase)) {
                    bottle.type = RequestType.SET_POSE
                    bottle.pose = phrase
                    sharedDictionary[SharedKey.POSE] = phrase
                }
                else {
                    val msg = String.format("I do not know how to respond to \"%s\"", phrase)
                    // We may have gotten here via an error in a different command. If there is a prior
                    // error, use it
                    if(bottle.error.equals(BottleConstants.NO_ERROR)) bottle.error = msg
                }
            }
        }
        return null
    }

    // list the limits of your left hip y? (same logic as "handleBulkPropertyRequest)
    override fun visitHandleBulkPropertyQuestion(ctx: SpeechSyntaxParser.HandleBulkPropertyQuestionContext): Any? {
        if (ctx.Limits() != null) bottle.type = RequestType.GET_LIMITS
        else                      bottle.type = RequestType.GET_GOALS

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        if (ctx.Joint() != null) {
            var joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
            if (joint.equals(Joint.NONE)) {
                val msg = String.format("I don't have a joint %s, that I know of",
                                           ctx.Joint().getText())
                bottle.error = msg
            }
            else {
                sharedDictionary[SharedKey.JOINT] = joint
                sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            }
        }
        else {
            val msg = String.format("You didn't specify the name of a joint")
            bottle.error = msg
        }
        return null
    }

    // what are the limits of your left hip y? (same logic as "handleBulkPropertyQuestion)
    override fun visitHandleBulkPropertyRequest(ctx: SpeechSyntaxParser.HandleBulkPropertyRequestContext): Any? {
        if (ctx.Limits() != null) bottle.type = RequestType.GET_LIMITS
        else                      bottle.type = RequestType.GET_GOALS

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have %s joint, that I know of",
                                ctx.Joint().getText())
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        return null
    }

    override fun visitHandleGreeting(ctx: SpeechSyntaxParser.HandleGreetingContext): Any? {
        bottle.type = RequestType.NOTIFICATION
        bottle.text =  messageTranslator.randomGreetingResponse()
        return null
    }

    // List the properties of a joint
    override fun visitHandleListCommand1(ctx: SpeechSyntaxParser.HandleListCommand1Context): Any? {
        bottle.type = RequestType.LIST_MOTOR_PROPERTY
        val pname: String = ctx.Properties().getText() // plural
        setJointPropertyInMessage(bottle,pname)
        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format(
                    "My joints don't hava a property %s, that I know of",
                    pname.lowercase(Locale.getDefault())
            )
            bottle.error = msg
        }
        return null
    }

    // Tell me your joint positions
    override fun visitHandleListCommand2(ctx: SpeechSyntaxParser.HandleListCommand2Context) :Any? {
        bottle.type = RequestType.LIST_MOTOR_PROPERTY
        val pname: String = ctx.Properties().getText() // plural
        setJointPropertyInMessage(bottle,pname)
        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format(
                    "My joints don't hava a property %s, that I know of",
                    pname.lowercase(Locale.getDefault())
            )
            bottle.error = msg
        }
        return null
    }

    // initialize your joints
    override fun visitInitializeJoints(ctx: SpeechSyntaxParser.InitializeJointsContext): Any? {
        bottle.type = RequestType.INITIALIZE_JOINTS
        return null
    }

    // what is the id of your left hip y?
    override fun visitJointPropertyQuestion(ctx: SpeechSyntaxParser.JointPropertyQuestionContext): Any? {
        bottle.type = RequestType.GET_MOTOR_PROPERTY
        val property: String = ctx.Property().getText().lowercase()
        setJointPropertyInMessage(bottle,property)
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have a joint %s, that I know of", ctx.Joint().getText())
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format("I don't have a property %s, that I know of", property)
            bottle.error = msg
        }
        return null
    }

    // where is your left ear
    override fun visitLimbLocationQuestion(ctx: SpeechSyntaxParser.LimbLocationQuestionContext): Any? {
        // If axis was set previously, use it as default
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        // If side was set previously, use it as default
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        if (ctx.Appendage() == null) {
            bottle.type = RequestType.GET_JOINT_LOCATION
            var joint: Joint = sharedDictionary[SharedKey.JOINT] as Joint
            if (ctx.Joint() != null) joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
            if (joint.equals(Joint.NONE)) {
                val msg = String.format("I don't have a joint like that")
                bottle.error = msg
            }
            else {
                sharedDictionary[SharedKey.JOINT] = joint
                sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            }
        }
        else {
            bottle.type = RequestType.GET_APPENDAGE_LOCATION
            var appendage = Appendage.NONE
            if (ctx.Appendage() != null) appendage = determineAppendage(ctx.Appendage().getText(), side)
            bottle.appendage = appendage
            if (appendage.equals(Appendage.NONE)) {
                val msg = String.format("I don't have an appendage %s, that I know of",
                                     ctx.Appendage().getText())
                bottle.error = msg
            }
            else {
                sharedDictionary[SharedKey.APPENDAGE] = appendage
            }
        }
        return null
    }

    // What is your duty cycle? Name, age
    override fun visitMetricsQuestion(ctx: SpeechSyntaxParser.MetricsQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        val metric: String = ctx.Metric().getText().lowercase()
        if( metric.equals("cycles", ignoreCase = true) ||
            metric.equals("cycle count", ignoreCase = true) ) {
            bottle.metric = MetricType.CYCLECOUNT
        }
        else if( metric.equals("cycle time", ignoreCase = true) ) {
            bottle.metric = MetricType.CYCLETIME
        }
        else if( metric.equals("duty cycle", ignoreCase = true) ) {
            bottle.metric = MetricType.DUTYCYCLE
        }
        else {
            bottle.metric = MetricType.fromString(metric)
            if(bottle.metric.equals(MetricType.UNDEFINED)) {
                val msg = String.format("I did't know that I had a %s", metric)
                bottle.error = msg
            }
        }
        return null
    }

    // Map a command to holding a pose
    // to stand means to take the pose standing
    override fun visitMapPoseToCommand1(ctx: SpeechSyntaxParser.MapPoseToCommand1Context): Any? {
        bottle.type = RequestType.MAP_POSE
        if (ctx.phrase().size > 1) {
            val command:String = visit(ctx.phrase(0)).toString()
            bottle.command = CommandType.fromString(command)
            if(bottle.command.equals(CommandType.NONE)) {
                val msg = String.format("I didn't recognize the command %s", command)
                bottle.error = msg
            }
            bottle.pose = visit(ctx.phrase(1)).toString()
        }
        else {
            val msg = String.format("I need both a pose name and associated command")
            bottle.error = msg
        }
        return null
    }

    // to climb means you are climbing
    override fun visitMapPoseToCommand2(ctx: SpeechSyntaxParser.MapPoseToCommand2Context): Any? {
        bottle.type = RequestType.MAP_POSE
        if (ctx.phrase().size > 1) {
            val command:String = visit(ctx.phrase(0)).toString()
            bottle.command = CommandType.fromString(command)
            if(bottle.command.equals(CommandType.NONE)) {
                val msg = String.format("I didn't recognize the command %s", command)
                bottle.error = msg
            }
            bottle.pose = visit(ctx.phrase(1)).toString()
        }
        else {
            val msg = String.format("I need both a pose name and associated command")
            bottle.error = msg
        }
        return null
    }

    // to eat is to become eating
    override fun visitMapPoseToCommand3(ctx: SpeechSyntaxParser.MapPoseToCommand3Context): Any? {
        bottle.type = RequestType.MAP_POSE
        if (ctx.phrase().size > 1) {
            val command:String = visit(ctx.phrase(0)).toString()
            bottle.command = CommandType.fromString(command)
            if(bottle.command.equals(CommandType.NONE)) {
                val msg = String.format("I didn't recognize the command %s", command)
                bottle.error = msg
            }
            bottle.pose = visit(ctx.phrase(1)).toString()
        }
        else {
            val msg = String.format("I need both a pose name and associated command")
            bottle.error = msg
        }
        return null
    }
    // when i say climb take the pose climbing
    override fun visitMapPoseToCommand4(ctx: SpeechSyntaxParser.MapPoseToCommand4Context): Any? {
        bottle.type = RequestType.MAP_POSE
        if (ctx.phrase().size > 1) {
            val command: String = visit(ctx.phrase(0)).toString()
            val pose: String = visit(ctx.phrase(1)).toString()
            bottle.command = CommandType.fromString(command)
            if(bottle.command.equals(CommandType.NONE)) {
                val msg = String.format("what do you mean: %s?", command)
                bottle.error = msg
            }
            bottle.pose = pose
        }
        else {
            val msg = String.format("This mapping requires both a pose name and associated command")
            bottle.error = msg
        }
        return null
    }

    // when you climb then you are climbing
    override fun visitMapPoseToCommand5(ctx: SpeechSyntaxParser.MapPoseToCommand5Context): Any? {
        bottle.type = RequestType.MAP_POSE
        if (ctx.phrase().size > 1) {
            val command: String = visit(ctx.phrase(0)).toString()
            val pose: String = visit(ctx.phrase(1)).toString()
            bottle.command = CommandType.fromString(command)
            if(bottle.command.equals(CommandType.NONE)) {
                val msg = String.format("I didn't recognize the command %s", command)
                bottle.error = msg
            }
            bottle.pose = pose
        }
        else {
            val msg = String.format("I need both a pose name and associated command")
            bottle.error = msg
        }
        return null
    }

    // what is the z position of your left hip?
    // Identical to JointPropertyQuestion, but different word order
    override fun visitMotorPropertyQuestion1(ctx: SpeechSyntaxParser.MotorPropertyQuestion1Context): Any? {
        bottle.type = RequestType.GET_MOTOR_PROPERTY
        val property: String = ctx.Property().getText().lowercase()
        setJointPropertyInMessage(bottle,property)
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = sharedDictionary[SharedKey.JOINT] as Joint
        if (ctx.Joint() != null) joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            var msg: String = "You must specify a legal joint"
            if (ctx.Joint() != null) {
                msg = String.format("I don't have a joint %s, that I know of", ctx.Joint().getText())
            }
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }

        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format("I don't have a value %s, that I know of", property)
            bottle.error = msg
        }
        return null
    }

    // what is the speed of your left hip x?
    // Identical to MotorPropertyQuestion1, but different word order
    override fun visitMotorPropertyQuestion2(ctx: SpeechSyntaxParser.MotorPropertyQuestion2Context): Any? {
        bottle.type = RequestType.GET_MOTOR_PROPERTY
        val property: String = ctx.Property().getText().lowercase()
        setJointPropertyInMessage(bottle,property)
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = sharedDictionary[SharedKey.JOINT] as Joint
        if (ctx.Joint() != null) joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            var msg: String = "You must specify a legal joint"
            if (ctx.Joint() != null) {
                msg = String.format("I don't have a joint %s, that I know of", ctx.Joint().getText())
            }
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format("I don't have a property %s, that I know of", property)
            bottle.error = msg
        }
        return null
    }

    // move your left hip y to 45 degrees
    override fun visitMoveMotor(ctx: SpeechSyntaxParser.MoveMotorContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = Joint.NONE
        if (ctx.It() != null) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        else if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
        }
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have a joint like that")
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            bottle.joint = joint
        }
        // Property is fixed as position
        bottle.jointDynamicProperty = JointDynamicProperty.ANGLE
        bottle.value = ctx.Value().getText().toDouble()
        return null
    }

    // What are your dynamic motor properties
    // Get a list of either static or dynamic motor parameters. The return is in JSON format.
    // What are your static motor parameters
    override fun visitParameterListQuestion1(ctx: SpeechSyntaxParser.ParameterListQuestion1Context): Any? {
        bottle.type = RequestType.LIST_MOTOR_PROPERTIES
        // Indicate whether we want static or dynamic properties - by setting one or the other
        if( ctx.Dynamic()!=null ) bottle.jointDynamicProperty = JointDynamicProperty.STATE
        if( ctx.Static()!=null  ) bottle.jointDefinitionProperty = JointDefinitionProperty.ID
        return null
    }
    // What are the dynamic properties of your joints
    override fun visitParameterListQuestion2(ctx: SpeechSyntaxParser.ParameterListQuestion2Context): Any? {
        bottle.type = RequestType.LIST_MOTOR_PROPERTIES
        // Indicate whether we want static or dynamic properties - by setting one or the other
        if( ctx.Dynamic()!=null ) bottle.jointDynamicProperty = JointDynamicProperty.STATE
        if( ctx.Static()!=null  ) bottle.jointDefinitionProperty = JointDefinitionProperty.ID
        return null
    }

    // Are you there?
    override fun visitPersonalQuestion(ctx: SpeechSyntaxParser.PersonalQuestionContext?): Any? {
        bottle.type = RequestType.NOTIFICATION
        bottle.text = String.format("At your service")
        return null
    }
    // What is your current pose?
    override fun visitPoseQuestion(ctx: SpeechSyntaxParser.PoseQuestionContext): Any? {
        val pose = sharedDictionary[SharedKey.POSE].toString()
        bottle.type = RequestType.NOTIFICATION
        bottle.pose = pose
        bottle.text = String.format("My current pose is %s", pose)
        return null
    }

    // setMotorProperty is referenced twice in the syntax file, same logic just different order
    // set the position of your left hip y to 45 degrees
    // set the left hip y position to 45 degrees
    // set your left elbow torque to 1.2
    override fun visitSetMotorProperty(ctx: SpeechSyntaxParser.SetMotorPropertyContext): Any? {
       bottle.type = RequestType.SET_MOTOR_PROPERTY
        // Get the property
        setJointPropertyInMessage(bottle,ctx.Property().getText().lowercase())

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        if (ctx.Joint() != null) {
            bottle.joint = determineJoint(ctx.Joint().getText(), axis, side)
            sharedDictionary[SharedKey.JOINT] = bottle.joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT

        }
        else {
            val msg = String.format("I don't have a joint or limb like that")
            bottle.error = msg
        }

        // Vaue is numerical, "on/off", or speed name - depending on property type
        if (ctx.Value() != null) {
            bottle.value = ctx.Value().getText().toDouble()
        }
        if (ctx.Speed() != null) {
            bottle.text = ctx.Speed().getText()
        }
        else if (ctx.On() != null) {
            bottle.value = BottleConstants.ON_VALUE
        }
        else if (ctx.Off() != null) {
            bottle.value = BottleConstants.OFF_VALUE
        }
        // Sanity check
        if( !bottle.joint.equals(Joint.NONE) && (
                    !bottle.jointDynamicProperty.equals(JointDynamicProperty.ANGLE) &&
                    !bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) &&
                    !bottle.jointDynamicProperty.equals(JointDynamicProperty.STATE) &&
                    !bottle.jointDynamicProperty.equals(JointDynamicProperty.TORQUE))) {
            bottle.error = "Only angle, speed, torque and state can be set for a joint"
        }
        else if( bottle.joint.equals(Joint.NONE) &&
                 bottle.jointDynamicProperty.equals(JointDynamicProperty.ANGLE) ) {
            bottle.error = "It doesn't make sense to set all joints to the same angle"
        }
        else if( !bottle.limb.equals(Limb.NONE) &&
                        (!bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) &&
                         !bottle.jointDynamicProperty.equals(JointDynamicProperty.TORQUE))) {
            bottle.error = "Speed or torque are the only properties that can be set for an entire limb."
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.ANGLE) && ctx.Value()==null )  {
            bottle.error = "The position must be specified as a numerical value"
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) ) {
            if(ctx.Speed()!=null) {
                setSpeedInMessage(bottle,ctx.Speed().toString())
            }
            else if( ctx.Value()==null ) {
                bottle.error = "Speed should be specified as fast, slow, normal, very fast or very slow"
            }
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.STATE) ) {
            if( bottle.value != BottleConstants.ON_VALUE &&
                bottle.value != BottleConstants.OFF_VALUE    )   {
                bottle.error = "State must be specified as on or off, enabled or disabled"
            }
        }

        return null
    }


    // Set the speed for all joints to one of the standard choices.
    // now move slowly
    override fun visitSetSpeed(ctx: SpeechSyntaxParser.SetSpeedContext): Any? {
        bottle.type = RequestType.SET_POSE
        val pose = poseForAdverb(ctx.Speed().text)
        bottle.pose = pose
        bottle.text = String.format("I am moving %s", ctx.Speed().text)
        return null
    }
    // If the joint is not specified, then straighten the entire body
    // straighten your left elbow.
    /* TO-DO Handle limbs */
    override fun visitStraightenJoint(ctx: SpeechSyntaxParser.StraightenJointContext): Any? {
        // A real joint
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // Get the property
        bottle.jointDynamicProperty = JointDynamicProperty.ANGLE
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = Joint.NONE
        if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.JOINT) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
        }
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("" +
                    " am i supposed to straighten?")
            bottle.error = msg
        }
        else if (joint.equals(Joint.LEFT_ELBOW_Y) ||
            joint.equals(Joint.RIGHT_ELBOW_Y) ||
            joint.equals(Joint.LEFT_KNEE_Y) ||
            joint.equals(Joint.RIGHT_KNEE_Y) ||
            joint.equals(Joint.LEFT_HIP_Y) ||
            joint.equals(Joint.RIGHT_HIP_Y) ) {
            // Straighten means 180 degrees
            val value = 180.0
            bottle.joint = joint
            bottle.value = value
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        else if (joint.equals(Joint.NECK_Y) ||
            joint.equals(Joint.NECK_Z) ||
            joint.equals(Joint.LEFT_HIP_Z) ||
            joint.equals(Joint.RIGHT_HIP_Z)) {
            // Straighten means 0 degrees
            val value = 0.0
            bottle.joint = joint
            bottle.value = value
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        return null
    }

    // why do you wear mittens
    override fun visitWhyMittens(ctx: SpeechSyntaxParser.WhyMittensContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric =  MetricType.MITTENS
        return null
    }

    // a phrase. Return space-separated words
    override fun visitWordList(ctx: SpeechSyntaxParser.WordListContext): Any? {
        val text = StringBuffer()
        var needsSpace = false
        for (token in ctx.children) {
            if (token == null) continue
            if (needsSpace) {
                text.append(" ")
            }
            needsSpace = true
            text.append(token.getText())
        }
        return text.toString()
    }

    //===================================== Helper Methods ======================================
    // Determine the specific appendage from the body part and side. (Side is not always needed).
    private fun determineAppendage(bodyPart: String, side: String?): Appendage {
        var result: Appendage = Appendage.NONE
        if (bodyPart.equals("EAR", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_EAR else Appendage.RIGHT_EAR
            }
        }
        else if (bodyPart.equals("EYE", ignoreCase = true) || bodyPart.equals("EYES", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_EYE else Appendage.RIGHT_EYE
            }
        }
        else if (bodyPart.equals("FINGER", ignoreCase = true) || bodyPart.equals("HAND", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_FINGER else Appendage.RIGHT_FINGER
            }
        }
        else if (bodyPart.equals("FOOT", ignoreCase = true) || bodyPart.equals("TOE", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_TOE else Appendage.RIGHT_TOE
            }
        }
        else if (bodyPart.equals("HEEL", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_HEEL else Appendage.RIGHT_HEEL
            }
        }
        else if (bodyPart.equals("NOSE", ignoreCase = true)) {
            result = Appendage.NOSE
        }
        if (result.equals(RequestType.NONE)) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineLimb did not find a match for %s",
                    bodyPart ))
        }
        return result
    }

    // Return TRUE if the phrase should be interpreted as one of the fixed commands. If so, update the 
    // request bottle appropriately.
    private fun determineCommandFromPhrase(phrase: String): Boolean {
        var success = true
        if (phrase == "die" || phrase == "exit" || phrase == "halt" || phrase == "quit" || phrase == "stop") {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.HALT
        }
        else if (phrase.startsWith("ignore") || phrase.equals("go to sleep",ignoreCase = true) ||
                 phrase.startsWith("sleep")) {
            sharedDictionary[SharedKey.ASLEEP] = "true"
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.SLEEP
        }
        else if (phrase.startsWith("pay attention") || phrase.equals("wake up", ignoreCase = true)) {
            sharedDictionary[SharedKey.ASLEEP] = "false"
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.WAKE
        }
        else if (phrase == "power off" || phrase == "shut down" || phrase == "shutdown") {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.SHUTDOWN
        }
        else if (phrase == "reset") {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.RESET
        }
        else if (phrase.startsWith("straighten")) {
            bottle.type = RequestType.SET_POSE
            bottle.pose = ConfigurationConstants.POSE_HOME
        }
        else {
            success = false
        }
        return success
    }

    // Determine the specific joint from the body part, side and axis. (The latter two are
    // not always needed).
    private fun determineJoint(bodyPart: String, axs: String?, side: String?): Joint {
        var axis = axs
        var result: Joint = Joint.NONE

        // Handle some synonyms
        if (axis != null) {
            if (axis.equals("horizontal", ignoreCase = true)) axis = "Z" else if (axis.equals(
                    "vertical",
                    ignoreCase = true
                ) ||
                axis.equals("why", ignoreCase = true)
            ) axis = "Y" else if (axis.equals("ex", ignoreCase = true)) axis = "X"
        }
        if (bodyPart.equals("ABS", ignoreCase = true)) {
            if (axis != null) {
                result = if (axis.equals("X", ignoreCase = true)) Joint.ABS_X else if (axis.equals(
                        "Y",
                        ignoreCase = true
                    )
                ) Joint.ABS_Y else Joint.ABS_Z
            }
        }
        else if (bodyPart.equals("ANKLE", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Joint.LEFT_ANKLE_Y else Joint.RIGHT_ANKLE_Y
            }
        }
        else if (bodyPart.equals("BUST", ignoreCase = true) || bodyPart.equals("CHEST", ignoreCase = true)) {
            if (axis != null) {
                result = if (axis.equals("X", ignoreCase = true)) Joint.BUST_X else Joint.BUST_Y
            }
        }
        else if (bodyPart.equals("ELBOW", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Joint.LEFT_ELBOW_Y else Joint.RIGHT_ELBOW_Y
            }
        }
        else if (bodyPart.equals("NECK", ignoreCase = true)) {
            if (axis != null) {
                result = if (axis.equals("Y", ignoreCase = true)) Joint.NECK_Y else Joint.NECK_Z
            }
        }
        else if (bodyPart.equals("HIP", ignoreCase = true) || bodyPart.equals("THIGH", ignoreCase = true)) {
            if (axis != null && side != null) {
                if (side.equals("left", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.LEFT_HIP_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.LEFT_HIP_Y else Joint.LEFT_HIP_Z
                }
                else if (side.equals("right", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.RIGHT_HIP_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.RIGHT_HIP_Y else Joint.RIGHT_HIP_Z
                }
            }
        }
        else if (bodyPart.equals("KNEE", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Joint.LEFT_KNEE_Y else Joint.RIGHT_KNEE_Y
            }
        }
        else if (bodyPart.equals("SHOULDER", ignoreCase = true) || bodyPart.equals("ARM", ignoreCase = true)) {
            if (axis != null && side != null) {
                if (side.equals("left", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.LEFT_SHOULDER_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.LEFT_SHOULDER_Y else Joint.LEFT_SHOULDER_Z
                }
                else if (side.equals("right", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.RIGHT_SHOULDER_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.RIGHT_SHOULDER_Y else Joint.RIGHT_SHOULDER_Z
                }
            }
        }
        if (result.equals(RequestType.NONE)) {
            LOGGER.info(String.format(
                    "WARNING: StatementTranslator.determineJoint did not find a match for %s",
                    bodyPart))
        }
        return result
    }



    // Determine the specific limb from the body part and side. (Side is not always needed).
    // A limb is a grouping of joints, e.g. "arm" includes elbow and shoulder.
    private fun determineLimb(bodyPart: String, side: String?): Limb {
        var result: Limb = Limb.NONE
        if (bodyPart.equals("arm", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Limb.LEFT_ARM else Limb.RIGHT_ARM
            }
        }
        else if (bodyPart.equals("leg", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Limb.LEFT_LEG else Limb.RIGHT_LEG
            }
        }
        else if (bodyPart.equals("back", ignoreCase = true) || bodyPart.equals("torso", ignoreCase = true)) {
            result = Limb.TORSO
        }
        else if (bodyPart.equals("head", ignoreCase = true)) {
            result = Limb.HEAD
        }
        if (result.equals(Limb.NONE)) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineLimb did not find a match for %s",
                    bodyPart))
        }
        return result
    }

    // Determine side from the supplied string. If the string is "other", return
    // the side different from the last used.
    private fun determineSide(text: String, dict: MutableMap<SharedKey, Any>): String {
        var side = "right"
        if (text.equals("left", ignoreCase = true)) side = "left"
        else if (text.equals("other", ignoreCase = true)) {
            val former = dict[SharedKey.SIDE].toString()
            side = if (former.equals("left", ignoreCase = true)) "right" else "left"
        }
        return side
    }

    // The poses returned here are expected to exist in the Pose table of the database.
    // Canonical names are: very slow speed,slow speed,normal speed,fast speed,very fast speed
    private fun poseForAdverb(adverb: String): String {
        val speed = adverb.lowercase()
        val currentSpeed = sharedDictionary[SharedKey.SPEED].toString()
        if(speed.contains("faster") ||
            speed.contains("quicker")) {
            if(currentSpeed.equals("very slow speed")) sharedDictionary[SharedKey.SPEED] = "slow speed"
            else if(currentSpeed.equals("slow speed")) sharedDictionary[SharedKey.SPEED] = "normal speed"
            else if(currentSpeed.equals("normal speed")) sharedDictionary[SharedKey.SPEED] = "fast speed"
            else if(currentSpeed.equals("fast speed")) sharedDictionary[SharedKey.SPEED] = "very fast speed"
        }
        else if (speed.contains("slower")) {
            if(currentSpeed.equals("very fast speed")) sharedDictionary[SharedKey.SPEED] = "fast speed"
            else if(currentSpeed.equals("fast speed")) sharedDictionary[SharedKey.SPEED] = "normal speed"
            else if(currentSpeed.equals("normal speed")) sharedDictionary[SharedKey.SPEED] = "slow speed"
            else if(currentSpeed.equals("slow speed")) sharedDictionary[SharedKey.SPEED] = "very slow speed"
        }
        else if (speed.contains("slow motion")) {
            sharedDictionary[SharedKey.SPEED] = "very slow speed"
        }
        else if(speed.contains("slow")) {
            if(speed.contains("very")) {
                sharedDictionary[SharedKey.SPEED] = "very slow speed"
            }
            else {
                sharedDictionary[SharedKey.SPEED] = "slow speed"
            }
        }
        else if(speed.contains("fast") ||
                speed.contains("quick")) {
            if(speed.contains("very")) {
                sharedDictionary[SharedKey.SPEED] = "very fast speed"
            }
            else {
                sharedDictionary[SharedKey.SPEED] = "fast speed"
            }
        }
        else if(speed.contains("normal")) {
            sharedDictionary[SharedKey.SPEED] = "normal speed"
        }
        return sharedDictionary[SharedKey.SPEED].toString()   // Must be a pose name
    }

    // Determine a joint property from the supplied string. It may be either a static
    // or dynamic property. Take care of recognized aliases. The name may be plural
    // in some settings. Set the appropriate property in the supplied message.
    private fun setJointPropertyInMessage(msg: MessageBottle, name: String) {
        var pname = name
        if (pname.endsWith("s") || pname.endsWith("S")) {
            pname = pname.substring(0, pname.length - 1).uppercase(Locale.getDefault())
        }
        var isDynamic = true
        if (pname.equals("angle", ignoreCase = true))              pname = "ANGLE"
        else if (pname.equals("position", ignoreCase = true ))     pname = "ANGLE"
        else if (pname.equals("load", ignoreCase = true ))         pname = "TORQUE"
        else if (pname.equals("max angle", ignoreCase = true))     pname ="MAXIMUMANGLE"
        else if (pname.equals("min angle", ignoreCase = true))     pname ="MINIMUMANGLE"
        else if (pname.equals("maximum angle", ignoreCase = true)) pname ="MAXIMUMANGLE"
        else if (pname.equals("minimum angle", ignoreCase = true)) pname ="MINIMUMANGLE"
        else if (pname.equals("motor type", ignoreCase = true))    pname ="MOTORTYPE"
        else if (pname.equals("range", ignoreCase = true))         pname ="RANGE"
        else if (pname.equals("speed", ignoreCase = true))         pname ="SPEED"
        else if (pname.equals("state", ignoreCase = true))         pname = "STATE"
        else if (pname.equals("temp", ignoreCase = true))          pname = "TEMPERATURE"
        else if (pname.equals("temperature", ignoreCase = true))   pname = "TEMPERATURE"
        else if (pname.equals("torque", ignoreCase = true))        pname = "TORQUE"
        else if (pname.equals("velocity", ignoreCase = true))      pname = "SPEED"
        else if (pname.equals("velocitie", ignoreCase = true))     pname = "SPEED"
        else if (pname.equals("voltage", ignoreCase = true))       pname = "VOLTAGE"
        else {
            isDynamic = false
        }

        if (pname.equals("id", ignoreCase = true))               pname = "ID"
        else if (pname.equals("motor type", ignoreCase = true))  pname = "MOTORTYPE"
        else if (pname.equals("offset", ignoreCase = true))      pname ="OFFSET"
        else if (pname.equals("orientation", ignoreCase = true)) pname ="ORIENTATION"

        if( isDynamic ) msg.jointDynamicProperty = JointDynamicProperty.fromString(pname)
        else            msg.jointDefinitionProperty = JointDefinitionProperty.fromString(pname)

    }
    // If speed is specified as a word, then convert to a numeric value
    private fun setSpeedInMessage(msg: MessageBottle, speed: String) {
        if(speed.contains("slow")) {
            if(speed.contains("very")) {msg.value = 2.0}
            else {msg.value = 5.0}
        }
        else if(speed.contains("fast") ||
            speed.contains("quick")) {
            if(speed.contains("very")) { msg.value = 100.0}
            else { msg.value = 80.0 }
        }
        else { msg.value = 20.0 }   // normal
    }

    private val CLSS = "StatementTranslator"
    private val LOGGER = Logger.getLogger(CLSS)
    private val DEBUG: Boolean

    /**
     * @param bot a request container supplied by the framework. It is our job
     * to fully configure it.
     * @param shared a parameter dictionary used to communicate between invocations
     */
    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_COMMAND)
        bottle = bot
        messageTranslator = MessageTranslator()
    }
}