/**
 * Copyright 2022-2025. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.speech.translate

// The following are classes generated by the parser. @See SpeechSyntaxParser
import chuckcoughlin.bert.common.message.*
import chuckcoughlin.bert.common.model.*
import chuckcoughlin.bert.speech.process.FaceMessageHandler
import chuckcoughlin.bert.sql.db.Database
import chuckcoughlin.bert.syntax.SpeechSyntaxBaseVisitor
import chuckcoughlin.bert.syntax.SpeechSyntaxParser
import java.util.*
import java.util.logging.Logger

/**
 * This translator takes spoken lines of text and converts them into
 * "Message Bottles" (requests). Note that the "visit" methods all return null,
 * an indicator that there is no further traversing the parse tree.
 */
class StatementTranslator(bot: MessageBottle, private val sharedDictionary: MutableMap<SharedKey, Any>) :
    SpeechSyntaxBaseVisitor<Any>() {
    private val bottle: MessageBottle
    private val messageTranslator: MessageTranslator

    // These do the actual translations. Text->RequestBottle.
    // NOTE: Any action, state or pose names require database access to fill in the details.c
    // ================================= Overridden Methods =====================================
    //
    // assume the pose
    override fun visitAssumePose(ctx: SpeechSyntaxParser.AssumePoseContext): Any? {
        bottle.type = RequestType.EXECUTE_POSE
        if (ctx.phrase() != null) {
            val pose: String = visit(ctx.phrase()).toString()
            sharedDictionary[SharedKey.POSE] = pose
            bottle.arg = pose
        }
        if(ctx.Value() != null ) {
            try {
                bottle.value = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        else {
            bottle.value = 1.0  // Default index
        }
        bottle.text = messageTranslator.randomAcknowledgement()
        return null
    }
    // How tall are you?
    override fun visitAttributeQuestion(ctx: SpeechSyntaxParser.AttributeQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        val attribute: String = ctx.Attribute().getText()
        if (attribute.equals("old", ignoreCase = true)) {
            bottle.metric =  MetricType.AGE
        }
        else if (attribute.equals("tall", ignoreCase = true)) {
            bottle.metric = MetricType.HEIGHT
        }
        else {
            val msg = String.format("I don't know what %s means", attribute)
            bottle.error = msg
        }
        return null
    }

    // List your joints
    override fun visitBodyPartListQuestion(ctx: SpeechSyntaxParser.BodyPartListQuestionContext): Any? {
        bottle.type = RequestType.JSON
        if( ctx.Bones()!=null )       bottle.jtype = JsonType.BONE_NAMES
        if( ctx.Appendages()!=null ) bottle.jtype = JsonType.END_EFFECTOR_NAMES
        if( ctx.Motors()!=null  )    bottle.jtype = JsonType.JOINT_NAMES
        if( ctx.Limbs()!=null  )     bottle.jtype = JsonType.LIMB_NAMES
        return null
    }
    // What are the names of your joints
    override fun visitBodyPartNamesQuestion(ctx: SpeechSyntaxParser.BodyPartNamesQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric = MetricType.LIST
        if( ctx.Bones()!=null ) bottle.jtype = JsonType.BONE_NAMES
        if( ctx.Appendages()!=null ) bottle.jtype = JsonType.END_EFFECTOR_NAMES
        if( ctx.Motors()!=null  )    bottle.jtype = JsonType.JOINT_NAMES
        if( ctx.Limbs()!=null  )     bottle.jtype = JsonType.LIMB_NAMES
        return null
    }

    // Describe your current pose
    override fun visitCurrentPoseDescription(ctx: SpeechSyntaxParser.CurrentPoseDescriptionContext): Any? {
        bottle.type = RequestType.JSON
        bottle.jtype= JsonType.JOINT_POSITIONS
        return null
    }
    // List values from the database
    // List your poses
    override fun visitDatabaseListQuestion(ctx: SpeechSyntaxParser.DatabaseListQuestionContext): Any? {
        bottle.type = RequestType.JSON
        if( ctx.Faces()!=null )     bottle.jtype = JsonType.FACE_NAMES
        if( ctx.Poses()!=null  )    bottle.jtype = JsonType.POSE_NAMES
        if( ctx.Actions()!=null  )  bottle.jtype = JsonType.ACTION_NAMES
        return null
    }
    // List values from the database
    // What actions do you know
    override fun visitDatabaseActionNamesQuestion(ctx: SpeechSyntaxParser.DatabaseActionNamesQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric = MetricType.LIST
        bottle.jtype = JsonType.ACTION_NAMES
        return null
    }
    // List values from the database
    // Who do you know
    override fun visitDatabaseFaceNamesQuestion(ctx: SpeechSyntaxParser.DatabaseFaceNamesQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric = MetricType.LIST
        bottle.jtype = JsonType.FACE_NAMES
        return null
    }
    // List values from the database
    // What are the names of your poses
    override fun visitDatabaseNamesQuestion(ctx: SpeechSyntaxParser.DatabaseNamesQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric = MetricType.LIST
        if( ctx.Faces()!=null )     bottle.jtype = JsonType.FACE_NAMES
        if( ctx.Poses()!=null  )    bottle.jtype = JsonType.POSE_NAMES
        if( ctx.Actions()!=null  )  bottle.jtype = JsonType.ACTION_NAMES
        return null
    }
    // List values from the database
    // What poses do you know
    override fun visitDatabasePoseNamesQuestion(ctx: SpeechSyntaxParser.DatabasePoseNamesQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric = MetricType.LIST
        bottle.jtype = JsonType.POSE_NAMES
        return null
    }

    // Define "salute" from "saluting"
    override fun visitDefineAction1(ctx: SpeechSyntaxParser.DefineAction1Context): Any? {
        val phrases = ctx.phrase()
        if( phrases.size>1 ) {
            val act = phrases[0].text
            val series = phrases[1].text
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.CREATE_ACTION
            bottle.arg = series
            bottle.text = act
        }
        else {
            bottle.error = "you must specify both pose series and action names"
        }
        return null
    }
    // The message arg is the series, the text is the action name
    // Use "saluting" to define "salute"
    override fun visitDefineAction2(ctx: SpeechSyntaxParser.DefineAction2Context): Any? {
        val phrases = ctx.phrase()
        if( phrases.size>1 ) {
            val act = phrases[1].text
            val series = phrases[0].text
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.CREATE_ACTION
            bottle.arg = series
            bottle.text = act
        }
        else {
            bottle.error = "you must specify both action name and pose series name"
        }
        return null
    }
    // Define a specified pose as the current position
    // you are singing 2
    override fun visitDefinePose(ctx: SpeechSyntaxParser.DefinePoseContext): Any? {
        val pose: String = visit(ctx.phrase()).toString()
        sharedDictionary[SharedKey.POSE] = pose
        bottle.type = RequestType.COMMAND
        bottle.command = CommandType.CREATE_POSE
        bottle.arg = pose
        if(ctx.Value() != null ) {
            try {
                bottle.value = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        else {
            bottle.value = 1.0  // Default index
        }
        sharedDictionary[SharedKey.POSE] = pose
        return null
    }

    // Delete a pose or user given the name
    //    forget Chuck
    override fun visitDeleteUserData(ctx: SpeechSyntaxParser.DeleteUserDataContext): Any? {
        bottle.type = RequestType.COMMAND
        val pose: String = ctx.phrase().getText()
        bottle.command = CommandType.DELETE_USER_DATA
        if(pose.isBlank()) {
            val msg = String.format("an argument is required")
            bottle.error = msg
        }
        bottle.arg = pose
        return null
    }
    // Apply "freeze" or "relax" to: Joints, Limbs, or the entire robot. "hold" is the same as "freeze".
    // relax your left arm
    override fun visitEnableTorque(ctx: SpeechSyntaxParser.EnableTorqueContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        bottle.jointDynamicProperty = JointDynamicProperty.STATE
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        // If side was set previously, use it as default
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        if (ctx.Freeze() != null || ctx.Hold() != null) {
            bottle.value = ConfigurationConstants.ON_VALUE
        }
        else if (ctx.Relax() != null) {
            bottle.value = ConfigurationConstants.OFF_VALUE
        }
        // If both Limb() and Joint() are missing, then we apply to the entire robot
        var joint: Joint = Joint.NONE
        var limb = Limb.NONE
        if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.JOINT) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
        }
        if (!joint.equals(Joint.NONE)) {
            bottle.joint= joint
            if (ctx.Freeze() != null || ctx.Hold() != null) {
                bottle.value = ConfigurationConstants.ON_VALUE
            }
            else {
                bottle.value = ConfigurationConstants.OFF_VALUE
            }
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        else {
            if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.LIMB) {
                limb = sharedDictionary[SharedKey.LIMB] as Limb
            }
            if (ctx.Limb() != null) {
                limb = determineLimb(ctx.Limb().getText(), side)
            }
            if( !limb.equals(Limb.NONE) ) {
                bottle.type = RequestType.SET_LIMB_PROPERTY
                bottle.limb = limb

                var value = ConfigurationConstants.OFF_VALUE
                if (ctx.Freeze() != null || ctx.Hold() != null) value = ConfigurationConstants.ON_VALUE
                bottle.value = value

                sharedDictionary[SharedKey.LIMB] = limb
                sharedDictionary[SharedKey.IT] = SharedKey.LIMB
            }

            LOGGER.info(String.format("%s.visitEnableTorque: %s %s %s", CLSS, bottle.limb.name,bottle.joint.name,bottle.value.toString()))
        }
        return null
    }

    // Handle a (possible) multi-word command. The actual action may depend on context. In order ...
    //    1) Check for several "well-known" commands
    //    2) Execute an action, if it exists.
    //    3) Interpret the phrase as a user name, if a face association is pending
    //    4) Report an error
    //
    // carry the torch, go limp.
    override fun visitHandleArbitraryCommandOrResponse(ctx: SpeechSyntaxParser.HandleArbitraryCommandOrResponseContext): Any? {
        LOGGER.info(String.format("%s.visitHandleArbitraryCommand: LAST RESORT error=%s -", CLSS, bottle.error))
        if (ctx.phrase() != null) {
            val phrase: String = visit(ctx.phrase()).toString()
            // First handle "well-known" commands
            if (!determineCommandFromPhrase(phrase)) {   // Configures bottle
                // Not a command
                if( phrase.equals("reset",ignoreCase = true) ) {
                    bottle.type = RequestType.RESET
                }
                // Next check to see if this is an action
                else if (Database.actionExists(phrase)) {
                    bottle.type = RequestType.EXECUTE_ACTION
                    bottle.arg = phrase
                    sharedDictionary[SharedKey.POSE] = phrase
                }
                // Finally associate the phrase with the current face
                else if(FaceMessageHandler.associateNameWithFace(phrase)) {
                    ; // Save the name with FaceDetails
                }
                else {
                    val msg = String.format("I do not know how to respond to \"%s\"", phrase)
                    // We may have gotten here via an error in a different command. If there is a prior
                    // error, use it
                    if(bottle.error.equals(BottleConstants.NO_ERROR)) bottle.error = msg
                }
            }
        }
        return null
    }

    // list the limits of your left hip y? (same logic as "handleBulkPropertyRequest)
    override fun visitHandleBulkPropertyQuestion(ctx: SpeechSyntaxParser.HandleBulkPropertyQuestionContext): Any? {
        bottle.type = RequestType.JSON
        if (ctx.Limits() != null) bottle.jtype = JsonType.MOTOR_LIMITS
        else                      bottle.jtype = JsonType.MOTOR_GOALS

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        if (ctx.Joint() != null) {
            var joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
            if (joint.equals(Joint.NONE)) {
                val msg = String.format("I don't have a joint %s, that I know of",
                                           ctx.Joint().getText())
                bottle.error = msg
            }
            else {
                sharedDictionary[SharedKey.JOINT] = joint
                sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            }
        }
        else {
            val msg = String.format("You didn't specify the name of a joint")
            bottle.error = msg
        }
        return null
    }

    // what are the limits of your left hip y? (same logic as "handleBulkPropertyQuestion)
    override fun visitHandleBulkPropertyRequest(ctx: SpeechSyntaxParser.HandleBulkPropertyRequestContext): Any? {
        bottle.type = RequestType.JSON
        if (ctx.Limits() != null) bottle.jtype = JsonType.MOTOR_LIMITS
        else                      bottle.jtype = JsonType.MOTOR_GOALS

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have %s joint, that I know of",
                                ctx.Joint().getText())
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        return null
    }

    override fun visitHandleGreeting(ctx: SpeechSyntaxParser.HandleGreetingContext): Any? {
        bottle.type = RequestType.NOTIFICATION
        bottle.text =  messageTranslator.randomGreetingResponse()
        return null
    }

    // List the properties of a joint
    // tell me your motor speeds
    override fun visitHandleListCommand(ctx: SpeechSyntaxParser.HandleListCommandContext): Any? {
        bottle.type = RequestType.JSON
        if (ctx.Properties() != null) {
            val pname: String = ctx.Properties().getText() // plural
            setJointPropertyInMessage(bottle, pname)
            if (!bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE)) {
                when (bottle.jointDefinitionProperty) {
                    JointDefinitionProperty.OFFSET        -> bottle.jtype = JsonType.JOINT_OFFSETS
                    JointDefinitionProperty.ORIENTATION   -> bottle.jtype = JsonType.JOINT_ORIENTATIONS
                    JointDefinitionProperty.ID            -> bottle.jtype = JsonType.JOINT_IDS
                    JointDefinitionProperty.MOTORTYPE     -> bottle.jtype = JsonType.JOINT_TYPES
                    else -> {
                        val msg = String.format("we do not support listing %s",pname)
                        bottle.error = msg
                    }
                }
            }
            else if (!bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
                when (bottle.jointDynamicProperty) {
                    JointDynamicProperty.ANGLE -> bottle.jtype = JsonType.JOINT_POSITIONS
                    JointDynamicProperty.SPEED -> bottle.jtype = JsonType.JOINT_SPEEDS
                    JointDynamicProperty.STATE -> bottle.jtype = JsonType.JOINT_STATES
                    JointDynamicProperty.TORQUE -> bottle.jtype = JsonType.JOINT_TORQUES
                    JointDynamicProperty.TEMPERATURE -> bottle.jtype = JsonType.JOINT_TEMPERATURES
                    JointDynamicProperty.VOLTAGE -> bottle.jtype = JsonType.JOINT_VOLTAGES
                    else -> {
                        val msg = String.format("we do not support listing %s",pname)
                        bottle.error = msg
                    }
                }
            }
            else {
                val msg = String.format( "My joints don't hava %s, that I know of", pname.lowercase(Locale.getDefault())
                )
                bottle.error = msg
            }
        }
        else {
            val msg = "you must must specify a motor property like id, angle, or speed"
            bottle.error = msg
        }

        return null
    }

    // initialize your joints
    override fun visitInitializeJoints(ctx: SpeechSyntaxParser.InitializeJointsContext): Any? {
        bottle.type = RequestType.INITIALIZE_JOINTS
        return null
    }

    // what is the id of your left hip y?
    override fun visitJointPropertyQuestion(ctx: SpeechSyntaxParser.JointPropertyQuestionContext): Any? {
        bottle.type = RequestType.GET_MOTOR_PROPERTY
        val property: String = ctx.Property().getText().lowercase()
        setJointPropertyInMessage(bottle,property)
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have a joint %s, that I know of", ctx.Joint().getText())
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format("I don't have a property %s, that I know of", property)
            bottle.error = msg
        }
        return null
    }

    // where is your left ear
    override fun visitJointLocationQuestion(ctx: SpeechSyntaxParser.JointLocationQuestionContext): Any? {
        // If axis was set previously, use it as default
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        // If side was set previously, use it as default
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        if (ctx.Appendage() == null) {
            bottle.type = RequestType.GET_JOINT_LOCATION
            var joint: Joint = sharedDictionary[SharedKey.JOINT] as Joint
            if (ctx.Joint() != null) joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
            if( joint==Joint.NONE ) {
                val msg = String.format("I don't have a joint like that")
                bottle.error = msg
            }
            else {
                sharedDictionary[SharedKey.JOINT] = joint
                sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            }
        }
        else {
            bottle.type = RequestType.GET_APPENDAGE_LOCATION
            var appendage = Appendage.NONE
            if (ctx.Appendage() != null) appendage = determineEndEffector(ctx.Appendage().getText(), side)
            bottle.appendage = appendage
            if( appendage==Appendage.NONE ) {
                val msg = String.format("I don't have a body part %s, that I know of",
                                     ctx.Appendage().text )
                bottle.error = msg
            }
            else {
                sharedDictionary[SharedKey.APPENDAGE] = appendage
            }
        }
        return null
    }

    // where is your left ear
    override fun visitLimbLocationList(ctx: SpeechSyntaxParser.LimbLocationListContext): Any? {
        bottle.type = RequestType.JSON
        bottle.jtype = JsonType.LIMB_LOCATIONS
        // If side was set previously, use it as default
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var limb : Limb
        if (ctx.Limb() == null) {
            limb = sharedDictionary[SharedKey.LIMB] as Limb
        }
        else {
            limb=determineLimb(ctx.Limb().toString(), side)
        }
        bottle.limb = limb
        if (limb.equals(Limb.NONE)) {
            val msg = String.format("I don't have a limb like that")
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.LIMB] = limb
            sharedDictionary[SharedKey.IT] = SharedKey.LIMB
        }
        return null
    }

    // What is your duty cycle? Name, age
    override fun visitMetricsQuestion(ctx: SpeechSyntaxParser.MetricsQuestionContext): Any? {
        bottle.type = RequestType.GET_METRIC
        val metric: String = ctx.Metric().getText().lowercase()
        if( metric.equals("cycles", ignoreCase = true) ||
            metric.equals("cycle count", ignoreCase = true) ) {
            bottle.metric = MetricType.CYCLECOUNT
        }
        else if( metric.equals("cycle time", ignoreCase = true) ) {
            bottle.metric = MetricType.CYCLETIME
        }
        else if( metric.equals("duty cycle", ignoreCase = true) ) {
            bottle.metric = MetricType.DUTYCYCLE
        }
        else {
            bottle.metric = MetricType.fromString(metric)
            if(bottle.metric.equals(MetricType.UNDEFINED)) {
                val msg = String.format("I did't know that I had a %s", metric)
                bottle.error = msg
            }
        }
        return null
    }

    // move your left hip y to 45 degrees
    override fun visitMoveMotor(ctx: SpeechSyntaxParser.MoveMotorContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = Joint.NONE
        if (ctx.It() != null) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        else if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
        }
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have a joint like that")
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            bottle.joint = joint
        }
        // Property is fixed as position
        bottle.jointDynamicProperty = JointDynamicProperty.ANGLE
        bottle.value = ctx.Value().getText().toDouble()
        return null
    }

    // Get a list of either static or dynamic motor parameters. The return is in JSON format.
    // List your static motor parameters
    // List the dynamic properties of your motors
    override fun visitParameterListQuestion(ctx: SpeechSyntaxParser.ParameterListQuestionContext): Any? {
        bottle.type = RequestType.JSON
        if( ctx.Dynamic()!=null ) bottle.jtype = JsonType.MOTOR_DYNAMIC_PROPERTIES
        if( ctx.Static()!=null  ) bottle.jtype = JsonType.MOTOR_STATIC_PROPERTIES
        return null
    }
    // Get a comma-separated list of either static or dynamic motor property names.
    // What are the names of your static motor parameters
    // What are the names the dynamic properties of your motors
    override fun visitParameterNamesQuestion(ctx: SpeechSyntaxParser.ParameterNamesQuestionContext): Any? {
        bottle.type = RequestType.JSON
        bottle.metric = MetricType.LIST
        if( ctx.Dynamic()!=null ) bottle.jtype = JsonType.MOTOR_DYNAMIC_PROPERTIES
        if( ctx.Static()!=null  ) bottle.jtype = JsonType.MOTOR_STATIC_PROPERTIES
        return null
    }


    // Are you there?
    override fun visitPersonalQuestion(ctx: SpeechSyntaxParser.PersonalQuestionContext?): Any? {
        bottle.type = RequestType.NOTIFICATION
        bottle.text = String.format("At your service")
        return null
    }
    // Describe your current pose
    override fun visitPoseDescription(ctx: SpeechSyntaxParser.PoseDescriptionContext): Any? {
        bottle.type = RequestType.JSON
        bottle.jtype= JsonType.POSE_DETAILS
        if (ctx.phrase() != null) {
            val pose: String = visit(ctx.phrase()).toString()
            bottle.arg = pose
        }
        if(ctx.Value() != null ) {
            try {
                bottle.value = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        else {
            bottle.value = 1.0  // Default index
        }
        return null
    }

    // setMotorProperty is referenced twice in the syntax file, same logic just different order
    // set the position of your left hip y to 45 degrees
    // set the left hip y position to 45 degrees
    // set your left elbow torque to 1.2
    override fun visitSetMotorProperty(ctx: SpeechSyntaxParser.SetMotorPropertyContext): Any? {
       bottle.type = RequestType.SET_MOTOR_PROPERTY
        // Get the property
        setJointPropertyInMessage(bottle,ctx.Property().getText().lowercase())

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText()
        sharedDictionary[SharedKey.AXIS] = axis
        if (ctx.Joint() != null) {
            bottle.joint = determineJoint(ctx.Joint().getText(), axis, side)
            sharedDictionary[SharedKey.JOINT] = bottle.joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT

        }
        else {
            val msg = String.format("I don't have a joint or limb like that")
            bottle.error = msg
        }

        // Value is numerical, "on/off", or speed name - depending on property type
        if (ctx.Value() != null) {
            bottle.value = ctx.Value().getText().toDouble()
        }
        if (ctx.Speed() != null) {
            bottle.text = ctx.Speed().getText()
        }
        else if (ctx.On() != null) {
            bottle.value = ConfigurationConstants.ON_VALUE
        }
        else if (ctx.Off() != null) {
            bottle.value = ConfigurationConstants.OFF_VALUE
        }
        // Sanity check
        if( bottle.joint!=Joint.NONE &&
            bottle.jointDynamicProperty!=JointDynamicProperty.ANGLE &&
            bottle.jointDynamicProperty!=JointDynamicProperty.SPEED &&
            bottle.jointDynamicProperty!=JointDynamicProperty.STATE &&
            bottle.jointDynamicProperty!=JointDynamicProperty.TORQUE  ) {
            bottle.error = "Only angle, speed, torque and state can be set for a joint"
        }
        else if( bottle.joint==Joint.NONE &&
                 bottle.jointDynamicProperty==JointDynamicProperty.ANGLE ) {
            bottle.error = "It doesn't make sense to set all joints to the same angle"
        }
        else if( !bottle.limb.equals(Limb.NONE) && (
                    !bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) &&
                            !bottle.jointDynamicProperty.equals(JointDynamicProperty.TORQUE))) {
            bottle.error = "Speed or torque are the only properties that can be set for an entire limb."
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.ANGLE) && ctx.Value()==null )  {
            bottle.error = "The position must be specified as a numerical value"
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) ) {
            if(ctx.Speed()!=null) {
                setSpeedInMessage(bottle,ctx.Speed().toString())
            }
            else if( ctx.Value()==null ) {
                bottle.error = "Speed should be specified as fast, slow, normal, very fast or very slow"
            }
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.STATE) ) {
            if( bottle.value != ConfigurationConstants.ON_VALUE &&
                bottle.value != ConfigurationConstants.OFF_VALUE    )   {
                bottle.error = "State must be specified as on or off, enabled or disabled"
            }
        }

        return null
    }


    // Set the speed for all joints to one of the standard choices.
    // now move slowly
    override fun visitSetSpeed(ctx: SpeechSyntaxParser.SetSpeedContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        bottle.jointDynamicProperty = JointDynamicProperty.SPEED
        setSpeedInMessage(bottle,ctx.Speed().text)
        // Request applies to all joints
        bottle.joint = Joint.NONE
        return null
    }
    // Associate a name with the current facial details. This is not a request.
    // My name is charlie
    override fun visitSetUserName(ctx: SpeechSyntaxParser.SetUserNameContext): Any? {
        bottle.type = RequestType.NONE
        if (ctx.Metric() != null) {
            val metric = ctx.Metric().toString()
            if( metric.equals("name")) {
                if (ctx.phrase() != null) {
                    val phrase: String=visit(ctx.phrase()).toString()
                    FaceMessageHandler.associateNameWithFace(phrase)
                }
            }
            else {
                bottle.error = "I only care about your name"
            }
        }

        return null
    }
    // If the joint is not specified, then straighten the entire body
    // straighten your left elbow.
    /* TO-DO Handle limbs */
    override fun visitStraightenJoint(ctx: SpeechSyntaxParser.StraightenJointContext): Any? {
        // A real joint
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // Get the property
        bottle.jointDynamicProperty = JointDynamicProperty.ANGLE
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE].toString()
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS].toString()
        if (ctx.Axis() != null) axis = ctx.Axis().getText().lowercase()
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = Joint.NONE
        if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.JOINT) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
        }

        var value:Double
        when (joint) {
            Joint.ABS_X -> value  = 180.0
            Joint.ABS_Y -> value = 180.0
            Joint.ABS_Z -> value = 0.0
            Joint.BUST_X -> value  = 180.0
            Joint.BUST_Y -> value  = 180.0
            Joint.NECK_Y -> value  = 0.0
            Joint.NECK_Z -> value  = 0.0
            Joint.LEFT_ANKLE_Y -> value  = 90.0
            Joint.LEFT_SHOULDER_Z -> value  = 0.0
            Joint.LEFT_ELBOW_Y -> value = 180.0
            Joint.LEFT_HIP_X -> value  = 180.0
            Joint.LEFT_HIP_Y -> value  = 180.0
            Joint.LEFT_HIP_Z -> value  = 0.0
            Joint.LEFT_KNEE_Y -> value  = 180.0
            Joint.LEFT_SHOULDER_X -> value  = 180.0
            Joint.LEFT_SHOULDER_Y -> value  = 180.0
            Joint.RIGHT_ANKLE_Y -> value = 90.0
            Joint.RIGHT_SHOULDER_Z -> value  = 0.0
            Joint.RIGHT_ELBOW_Y -> value = 180.0
            Joint.RIGHT_HIP_X -> value  = 180.0
            Joint.RIGHT_HIP_Y -> value  = 180.0
            Joint.RIGHT_HIP_Z -> value  = 0.0
            Joint.RIGHT_KNEE_Y -> value = 180.0
            Joint.RIGHT_SHOULDER_X -> value  = 180.0
            Joint.RIGHT_SHOULDER_Y -> value  = 180.0
            Joint.NONE -> {
                value = 0.0
                val msg = "what am i supposed to straighten?"
                bottle.error = msg
            }
        }
        bottle.joint = joint
        bottle.value = value
        sharedDictionary[SharedKey.JOINT] = joint
        sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        return null
    }

    // why do you wear mittens
    override fun visitWhyMittens(ctx: SpeechSyntaxParser.WhyMittensContext): Any? {
        bottle.type = RequestType.GET_METRIC
        bottle.metric =  MetricType.MITTENS
        return null
    }

    // a phrase. Return space-separated words
    override fun visitWordList(ctx: SpeechSyntaxParser.WordListContext): Any? {
        val text = StringBuffer()
        var needsSpace = false
        for (token in ctx.children) {
            if (token == null) continue
            if (needsSpace) {
                text.append(" ")
            }
            needsSpace = true
            text.append(token.getText())
        }
        return text.toString()
    }

    //===================================== Helper Methods ======================================
    private fun determineBone(bone: String, side: String?): Appendage {
        val bodyPart = bone.uppercase()
        var result: Appendage = Appendage.NONE
        if (bodyPart.equals("EAR", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_EAR else Appendage.RIGHT_EAR
            }
        }
        else if (bodyPart.equals("EYE") || bodyPart.equals("EYES", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_EYE else Appendage.RIGHT_EYE
            }
        }
        else if (bodyPart.equals("FINGER") || bodyPart.equals("HAND")) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_FINGER else Appendage.RIGHT_FINGER
            }
        }
        else if (bodyPart.equals("FOOT") || bodyPart.equals("TOE")) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_TOE else Appendage.RIGHT_TOE
            }
        }
        else if (bodyPart.equals("HEEL")) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Appendage.LEFT_HEEL else Appendage.RIGHT_HEEL
            }
        }
        else if (bodyPart.equals("NOSE", ignoreCase = true)) {
            result = Appendage.NOSE
        }
        if( result==Appendage.NONE ) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineEndEffector did not find a match for %s",
                bodyPart ))
        }
        return result
    }
    // Determine the specific end effector (appendage) from the body part and side. (Side is not always needed).
    // @param bodyPart - appendage (uppercase)
    private fun determineEndEffector(appendage: String, side: String?): Appendage {
        val bodyPart = appendage.uppercase()
        var result: Appendage = Appendage.NONE
        if (bodyPart.equals("EAR")) {
            if (side != null) {
                result = if (side.equals("left")) Appendage.LEFT_EAR else Appendage.RIGHT_EAR
            }
        }
        else if (bodyPart.equals("EYE") || bodyPart.equals("EYES")) {
            if (side != null) {
                result = if (side.equals("left")) Appendage.LEFT_EYE else Appendage.RIGHT_EYE
            }
        }
        else if (bodyPart.equals("FINGER") || bodyPart.equals("HAND")) {
            if (side != null) {
                result = if (side.equals("left")) Appendage.LEFT_FINGER else Appendage.RIGHT_FINGER
            }
        }
        else if (bodyPart.equals("FOOT") || bodyPart.equals("TOE")) {
            if (side != null) {
                result = if (side.equals("left")) Appendage.LEFT_TOE else Appendage.RIGHT_TOE
            }
        }
        else if (bodyPart.equals("HEEL")) {
            if (side != null) {
                result = if (side.equals("left")) Appendage.LEFT_HEEL else Appendage.RIGHT_HEEL
            }
        }
        else if (bodyPart.equals("NOSE")) {
            result = Appendage.NOSE
        }
        if( result==Appendage.NONE ) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineEndEffector did not find a match for %s",
                    bodyPart ))
        }
        return result
    }

    // Return TRUE if the phrase should be interpreted as one of the fixed commands. If so, update the 
    // request bottle appropriately.
    private fun determineCommandFromPhrase(phrase: String): Boolean {
        var success = true
        if (phrase == "die" || phrase == "exit" || phrase == "halt" || phrase == "quit" || phrase == "stop") {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.HALT
        }
        else if (phrase.startsWith("ignore") || phrase.equals("go to sleep",ignoreCase = true) ||
                 phrase.startsWith("sleep")) {
            sharedDictionary[SharedKey.ASLEEP] = "true"
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.SLEEP
        }
        else if (phrase.startsWith("pay attention") || phrase.equals("wake up", ignoreCase = true)) {
            sharedDictionary[SharedKey.ASLEEP] = "false"
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.WAKE
        }
        else if (phrase == "power off" || phrase == "shut down" || phrase == "shutdown") {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.SHUTDOWN
        }
        else if (phrase.startsWith("straighten")) {
            bottle.type = RequestType.EXECUTE_POSE
            bottle.arg = ConfigurationConstants.POSE_HOME
            bottle.value = ConfigurationConstants.POSE_HOME_INDEX
            sharedDictionary[SharedKey.POSE] = ConfigurationConstants.POSE_HOME
        }
        else {
            success = false
        }
        return success
    }

    // Determine the specific joint from the body part, side and axis. (The latter two are
    // not always needed).
    private fun determineJoint(part: String, axs: String?, side: String?): Joint {
        val bodyPart = part.uppercase()
        var axis = axs
        var result: Joint = Joint.NONE

        // Handle some synonyms
        if (axis != null) {
            if (axis.equals("horizontal", ignoreCase = true)) axis = "Z" else if (axis.equals(
                    "vertical",
                    ignoreCase = true
                ) ||
                axis.equals("why", ignoreCase = true)
            ) axis = "Y" else if (axis.equals("ex", ignoreCase = true)) axis = "X"
        }
        if (bodyPart.equals("ABS") || bodyPart.equals("ABDOMEN") ) {
            if (axis != null) {
                result = if (axis.equals("X", ignoreCase = true)) Joint.ABS_X else if (axis.equals(
                        "Y",
                        ignoreCase = true
                    )
                ) Joint.ABS_Y else Joint.ABS_Z
            }
        }
        else if (bodyPart.equals("ANKLE")) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Joint.LEFT_ANKLE_Y else Joint.RIGHT_ANKLE_Y
            }
        }
        else if (bodyPart.equals("BUST") || bodyPart.equals("CHEST", ignoreCase = true)) {
            if (axis != null) {
                result = if (axis.equals("X", ignoreCase = true)) Joint.BUST_X else Joint.BUST_Y
            }
        }
        else if (bodyPart.equals("ELBOW")) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Joint.LEFT_ELBOW_Y else Joint.RIGHT_ELBOW_Y
            }
        }
        else if (bodyPart.equals("NECK")) {
            if (axis != null) {
                result = if (axis.equals("Y")) Joint.NECK_Y else Joint.NECK_Z
            }
        }
        else if (bodyPart.equals("HIP") || bodyPart.equals("THIGH")) {
            if (axis != null && side != null) {
                if (side.equals("left", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.LEFT_HIP_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.LEFT_HIP_Y else Joint.LEFT_HIP_Z
                }
                else if (side.equals("right", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.RIGHT_HIP_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.RIGHT_HIP_Y else Joint.RIGHT_HIP_Z
                }
            }
        }
        else if (bodyPart.equals("KNEE")) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Joint.LEFT_KNEE_Y else Joint.RIGHT_KNEE_Y
            }
        }
        else if (bodyPart.equals("SHOULDER") || bodyPart.equals("ARM", ignoreCase = true)) {
            if (axis != null && side != null) {
                if (side.equals("left", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.LEFT_SHOULDER_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.LEFT_SHOULDER_Y else Joint.LEFT_SHOULDER_Z
                }
                else if (side.equals("right", ignoreCase = true)) {
                    result = if (axis.equals("X", ignoreCase = true)) Joint.RIGHT_SHOULDER_X else if (axis.equals(
                            "Y",
                            ignoreCase = true
                        )
                    ) Joint.RIGHT_SHOULDER_Y else Joint.RIGHT_SHOULDER_Z
                }
            }
        }
        if (result.equals(RequestType.NONE)) {
            LOGGER.info(String.format(
                    "WARNING: StatementTranslator.determineJoint did not find a match for %s",
                    bodyPart))
        }
        return result
    }



    // Determine the specific limb from the body part and side. (Side is not always needed).
    // A limb is a grouping of joints, e.g. "arm" includes elbow and shoulder.
    private fun determineLimb(bodyPart: String, side: String?): Limb {
        var result: Limb = Limb.NONE
        if (bodyPart.equals("arm", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Limb.LEFT_ARM else Limb.RIGHT_ARM
            }
        }
        else if (bodyPart.equals("leg", ignoreCase = true)) {
            if (side != null) {
                result = if (side.equals("left", ignoreCase = true)) Limb.LEFT_LEG else Limb.RIGHT_LEG
            }
        }
        else if (bodyPart.equals("back", ignoreCase = true) || bodyPart.equals("torso", ignoreCase = true)) {
            result = Limb.TORSO
        }
        else if (bodyPart.equals("head", ignoreCase = true)) {
            result = Limb.HEAD
        }
        if( result==Limb.NONE ) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineLimb did not find a match for %s",
                    bodyPart))
        }
        return result
    }

    // Determine side from the supplied string. If the string is "other", return
    // the side different from the last used.
    private fun determineSide(text: String, dict: MutableMap<SharedKey, Any>): String {
        var side = "right"
        if (text.equals("left", ignoreCase = true)) side = "left"
        else if (text.equals("other", ignoreCase = true)) {
            val former = dict[SharedKey.SIDE].toString()
            side = if (former.equals("left", ignoreCase = true)) "right" else "left"
        }
        return side
    }

    // The poses returned here are expected to exist in the Pose table of the database.
    // Canonical names are: very slow speed,slow speed,normal speed,fast speed,very fast speed
    private fun poseForAdverb(adverb: String): String {
        val speed = adverb.lowercase()
        val currentSpeed = sharedDictionary[SharedKey.SPEED].toString()
        if(speed.contains("faster") ||
            speed.contains("quicker")) {
            if(currentSpeed.equals("very slow speed")) sharedDictionary[SharedKey.SPEED] = "slow speed"
            else if(currentSpeed.equals("slow speed")) sharedDictionary[SharedKey.SPEED] = "normal speed"
            else if(currentSpeed.equals("normal speed")) sharedDictionary[SharedKey.SPEED] = "fast speed"
            else if(currentSpeed.equals("fast speed")) sharedDictionary[SharedKey.SPEED] = "very fast speed"
        }
        else if (speed.contains("slower")) {
            if(currentSpeed.equals("very fast speed")) sharedDictionary[SharedKey.SPEED] = "fast speed"
            else if(currentSpeed.equals("fast speed")) sharedDictionary[SharedKey.SPEED] = "normal speed"
            else if(currentSpeed.equals("normal speed")) sharedDictionary[SharedKey.SPEED] = "slow speed"
            else if(currentSpeed.equals("slow speed")) sharedDictionary[SharedKey.SPEED] = "very slow speed"
        }
        else if (speed.contains("slow motion")) {
            sharedDictionary[SharedKey.SPEED] = "very slow speed"
        }
        else if(speed.contains("slow")) {
            if(speed.contains("very")) {
                sharedDictionary[SharedKey.SPEED] = "very slow speed"
            }
            else {
                sharedDictionary[SharedKey.SPEED] = "slow speed"
            }
        }
        else if(speed.contains("fast") ||
                speed.contains("quick")) {
            if(speed.contains("very")) {
                sharedDictionary[SharedKey.SPEED] = "very fast speed"
            }
            else {
                sharedDictionary[SharedKey.SPEED] = "fast speed"
            }
        }
        else if(speed.contains("normal")) {
            sharedDictionary[SharedKey.SPEED] = "normal speed"
        }
        return sharedDictionary[SharedKey.SPEED].toString()   // Must be a pose name
    }

    // Determine a joint property from the supplied string. It may be either a static
    // or dynamic property. Take care of recognized aliases. The name may be plural
    // in some settings. Set the appropriate property in the supplied message.
    private fun setJointPropertyInMessage(msg: MessageBottle, name: String) {
        var pname = name
        if (pname.endsWith("s") || pname.endsWith("S")) {
            pname = pname.substring(0, pname.length - 1).uppercase(Locale.getDefault())
        }
        var isDynamic = true
        if (pname.equals("angle", ignoreCase = true))              pname = "ANGLE"
        else if (pname.equals("position", ignoreCase = true ))     pname = "ANGLE"
        else if (pname.equals("load", ignoreCase = true ))         pname = "LOAD"
        else if (pname.equals("max angle", ignoreCase = true))     pname ="MAXIMUMANGLE"
        else if (pname.equals("min angle", ignoreCase = true))     pname ="MINIMUMANGLE"
        else if (pname.equals("maximum angle", ignoreCase = true)) pname ="MAXIMUMANGLE"
        else if (pname.equals("minimum angle", ignoreCase = true)) pname ="MINIMUMANGLE"
        else if (pname.equals("motor type", ignoreCase = true))    pname ="MOTORTYPE"
        else if (pname.equals("range", ignoreCase = true))         pname ="RANGE"
        else if (pname.equals("max speed", ignoreCase = true))    pname ="MAXIMUMSPEED"
        else if (pname.equals("maximum speed", ignoreCase = true))pname ="MAXIMUMSPEED"
        else if (pname.equals("speed", ignoreCase = true))         pname ="SPEED"
        else if (pname.equals("state", ignoreCase = true))         pname = "STATE"
        else if (pname.equals("temp", ignoreCase = true))          pname = "TEMPERATURE"
        else if (pname.equals("temperature", ignoreCase = true))   pname = "TEMPERATURE"
        else if (pname.equals("max torque", ignoreCase = true))    pname ="MAXIMUMTORQUE"
        else if (pname.equals("maximum torque", ignoreCase = true))pname ="MAXIMUMTORQUE"
        else if (pname.equals("torque", ignoreCase = true))        pname = "TORQUE"
        else if (pname.equals("velocity", ignoreCase = true))      pname = "SPEED"
        else if (pname.equals("velocitie", ignoreCase = true))     pname = "SPEED"
        else if (pname.equals("voltage", ignoreCase = true))       pname = "VOLTAGE"
        else {
            isDynamic = false
        }

        if (pname.equals("id", ignoreCase = true))               pname = "ID"
        else if (pname.equals("motor type", ignoreCase = true))  pname = "MOTORTYPE"
        else if (pname.equals("offset", ignoreCase = true))      pname = "OFFSET"
        else if (pname.equals("orientation", ignoreCase = true)) pname = "ORIENTATION"

        if( isDynamic ) msg.jointDynamicProperty = JointDynamicProperty.fromString(pname)
        else            msg.jointDefinitionProperty = JointDefinitionProperty.fromString(pname)

    }
    // If speed is specified as a word, then convert to a numeric value
    private fun setSpeedInMessage(msg: MessageBottle, speed: String) {
        if(speed.contains("slow")) {
            if(speed.contains("very")) {msg.value = 2.0}
            else {msg.value = 5.0}
        }
        else if(speed.contains("fast") ||
            speed.contains("quick")) {
            if(speed.contains("very")) { msg.value = 150.0}
            else { msg.value = 100.0 }
        }
        else { msg.value = 40.0 }   // normal
    }

    private val CLSS = "StatementTranslator"
    private val LOGGER = Logger.getLogger(CLSS)
    private val DEBUG: Boolean

    /**
     */
    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_COMMAND)
        bottle = bot
        messageTranslator = MessageTranslator()
    }
}