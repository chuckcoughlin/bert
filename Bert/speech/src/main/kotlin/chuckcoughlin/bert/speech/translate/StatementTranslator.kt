/**
 * Copyright 2022-2025. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.speech.translate

// The following are classes generated by the parser. @See SpeechSyntaxParser
import chuckcoughlin.bert.common.message.*
import chuckcoughlin.bert.common.model.*
import chuckcoughlin.bert.speech.process.FaceMessageHandler
import chuckcoughlin.bert.sql.db.Database
import chuckcoughlin.bert.syntax.SpeechSyntaxBaseVisitor
import chuckcoughlin.bert.syntax.SpeechSyntaxParser
import java.util.*
import java.util.logging.Logger

/**
 * This translator takes spoken lines of text and converts them into
 * "Message Bottles" (requests). Note that the "visit" methods all return null,
 * an indicator that there is no further traversing the parse tree.
 */
class StatementTranslator(bot: MessageBottle, private val sharedDictionary: MutableMap<SharedKey, Any>) :
    SpeechSyntaxBaseVisitor<Any>() {
    private val bottle: MessageBottle
    private val messageTranslator: MessageTranslator

    // These do the actual translations. Text->RequestBottle.
    // NOTE: Any action, state or pose names require database access to fill in the details.c
    // ================================= Overridden Methods =====================================
    //
    // assume the pose
    override fun visitAssumePose(ctx: SpeechSyntaxParser.AssumePoseContext): Any? {
        bottle.type = RequestType.EXECUTE_POSE
        if (ctx.phrase() != null) {
            val pose: String = visit(ctx.phrase()).toString()
            sharedDictionary[SharedKey.POSE] = pose
            bottle.arg = pose
        }
        if(ctx.Value() != null ) {
            try {
                bottle.values[0] = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        else {
            bottle.values[0] = 1.0  // Default index
        }
        bottle.text = messageTranslator.randomAcknowledgement()
        return null
    }
    // How tall are you?
    override fun visitAttributeQuestion(ctx: SpeechSyntaxParser.AttributeQuestionContext): Any? {
        bottle.type = RequestType.METRIC
        val attribute: String = ctx.Attribute().getText()
        if (attribute.equals("old", ignoreCase = true)) {
            bottle.metric =  MetricType.AGE
        }
        else if (attribute.equals("tall", ignoreCase = true)) {
            bottle.metric = MetricType.HEIGHT
        }
        else {
            val msg = String.format("I don't know what %s means", attribute)
            bottle.error = msg
        }
        return null
    }

    // Describe your current pose
    override fun visitCurrentPoseDescription(ctx: SpeechSyntaxParser.CurrentPoseDescriptionContext): Any? {
        bottle.type = RequestType.JSON
        bottle.jtype= JsonType.JOINT_COORDINATES
        bottle.metric = MetricType.LIST
        return null
    }

    // Define "salute" from "saluting"
    override fun visitDefineAction1(ctx: SpeechSyntaxParser.DefineAction1Context): Any? {
        val phrases = ctx.phrase()
        if( phrases.size>1 ) {
            val act = phrases[0].text
            val series = phrases[1].text
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.CREATE_ACTION
            bottle.arg = act
            bottle.text = series
        }
        else {
            bottle.error = "you must specify both pose series and action names"
        }
        return null
    }
    // The message arg is the series, the text is the action name
    // Use "saluting" to define "salute"
    override fun visitDefineAction2(ctx: SpeechSyntaxParser.DefineAction2Context): Any? {
        val phrases = ctx.phrase()
        if( phrases.size>1 ) {
            val act = phrases[1].text
            val series = phrases[0].text
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.CREATE_ACTION
            bottle.arg = act
            bottle.text = series
        }
        else {
            bottle.error = "you must specify both action name and pose series name"
        }
        return null
    }
    // Follow 'salute' with 'wave'
    override fun visitDefineActionFollowOn(ctx: SpeechSyntaxParser.DefineActionFollowOnContext): Any? {
        val phrases = ctx.phrase()
        if( phrases.size>1 ) {
            val act = phrases[0].text
            val next = phrases[1].text
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.CREATE_NEXT_ACTION
            bottle.arg = act
            bottle.text = next
        }
        else {
            bottle.error = "you must specify both action name and a follow on"
        }
        return null
    }
    // Define a specified pose as the current position
    // you are singing 2
    override fun visitDefinePose(ctx: SpeechSyntaxParser.DefinePoseContext): Any? {
        val pose: String = visit(ctx.phrase()).toString()
        sharedDictionary[SharedKey.POSE] = pose
        bottle.type = RequestType.COMMAND
        bottle.command = CommandType.CREATE_POSE
        bottle.arg = pose
        if(ctx.Value() != null ) {
            try {
                bottle.values[0] = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        else {
            bottle.values[0] = 1.0  // Default index
        }
        sharedDictionary[SharedKey.POSE] = pose
        return null
    }

    // Delete a pose or user given the name
    //    forget Chuck
    override fun visitDeleteUserData(ctx: SpeechSyntaxParser.DeleteUserDataContext): Any? {
        bottle.type = RequestType.COMMAND
        bottle.command = CommandType.DELETE_FACE
        if( ctx.Action() != null )  bottle.command = CommandType.DELETE_ACTION
        else if( ctx.Pose() != null ) bottle.command = CommandType.DELETE_POSE

        val phrase: String = visit(ctx.phrase()).toString()
        if(phrase.isBlank()) {
            val msg = String.format("an argument is required")
            bottle.error = msg
        }
        if(ctx.Value()!=null ) {
            try {
                bottle.values[0] = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        bottle.arg = phrase
        return null
    }
    // Apply "freeze" or "relax" to: Joints, Limbs, or the entire robot. "hold" is the same as "freeze".
    // relax your left arm
    override fun visitEnableTorque(ctx: SpeechSyntaxParser.EnableTorqueContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        bottle.jointDynamicProperty = JointDynamicProperty.STATE
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        var value = ConfigurationConstants.OFF_VALUE
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        // If side was set previously, use it as default
        var side:Side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        if (ctx.Freeze() != null || ctx.Hold() != null) {
            value = ConfigurationConstants.ON_VALUE
            bottle.values[0] = value
        }
        else if (ctx.Relax() != null) {
            bottle.values[0] = value  // OFF_VÃ…LUE
        }
        // If both Limb() and Joint() are missing, then we apply to the entire robot
        var joint: Joint = Joint.NONE
        var limb = Limb.NONE
        if (ctx.It() != null ) {
            if( sharedDictionary[SharedKey.IT] == SharedKey.JOINT) {
                joint = sharedDictionary[SharedKey.JOINT] as Joint
            }
            if( sharedDictionary[SharedKey.IT] == SharedKey.LIMB) {
                limb = sharedDictionary[SharedKey.LIMB] as Limb
            }
            else {
                bottle.error = "you haven\'t told me what \"it\" refers to"
            }
        }
        if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
        }
        if (!joint.equals(Joint.NONE)) {
            bottle.joint= joint
            if (ctx.Freeze() != null || ctx.Hold() != null) {
                value = ConfigurationConstants.ON_VALUE
                bottle.values[0] = value
            }
            else {
                bottle.values[0] = value   // OFF_VALUE
            }
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            LOGGER.info(String.format("%s.visitEnableTorque: %s %s", CLSS, bottle.joint.name,value.toString()))
        }
        else {
            if (ctx.Limb() != null) {
                limb = determineLimb(ctx.Limb().getText(), side)
            }
            if( !limb.equals(Limb.NONE) ) {
                bottle.type = RequestType.SET_LIMB_PROPERTY
                bottle.limb = limb


                if (ctx.Freeze() != null || ctx.Hold() != null) value = ConfigurationConstants.ON_VALUE
                bottle.values[0] = value

                sharedDictionary[SharedKey.LIMB] = limb
                sharedDictionary[SharedKey.IT] = SharedKey.LIMB
                LOGGER.info(String.format("%s.visitEnableTorque: %s %s", CLSS, bottle.limb.name,value.toString()))
            }
        }
        return null
    }

    // Handle a (possible) multi-word command. The actual action may depend on context. In order ...
    //    1) Check for several "well-known" commands
    //    2) Execute an action, if it exists.
    //    3) Interpret the phrase as a user name, if a face association is pending
    //    4) Report an error
    //
    // carry the torch, go limp.
    override fun visitHandleArbitraryCommandOrResponse(ctx: SpeechSyntaxParser.HandleArbitraryCommandOrResponseContext): Any? {
        LOGGER.info(String.format("%s.visitHandleArbitraryCommand: LAST RESORT error=%s -", CLSS, bottle.error))
        if (ctx.phrase() != null) {
            val phrase: String = visit(ctx.phrase()).toString()
            // First handle "well-known" commands
            if (!determineCommandFromPhrase(phrase)) {   // Configures bottle
                // Not a command
                if( phrase.equals("reset",ignoreCase = true) ) {
                    bottle.type = RequestType.RESET
                }
                // Next check to see if this is an action
                else if (Database.actionExists(phrase)) {
                    bottle.type = RequestType.EXECUTE_ACTION
                    bottle.arg = phrase
                    sharedDictionary[SharedKey.ACTION] = phrase
                }
                // Finally associate the phrase with the current face
                else if(FaceMessageHandler.associateNameWithFace(phrase)) {
                    ; // Save the name with FaceDetails
                }
                else {
                    val msg = String.format("I do not know how to respond to \"%s\"", phrase)
                    // We may have gotten here via an error in a different command. If there is a prior
                    // error, use it
                    if(bottle.error.equals(BottleConstants.NO_ERROR)) bottle.error = msg
                }
            }
        }
        return null
    }



    override fun visitHandleGreeting(ctx: SpeechSyntaxParser.HandleGreetingContext): Any? {
        bottle.type = RequestType.NOTIFICATION
        bottle.text =  messageTranslator.randomGreetingResponse()
        return null
    }


    // initialize your joints
    override fun visitInitializeJoints(ctx: SpeechSyntaxParser.InitializeJointsContext): Any? {
        bottle.type = RequestType.INITIALIZE_JOINTS
        return null
    }

    // move your left finger 400 mm to the right
    // move your right finger up 200 mm
    // NOTE: There is some ambiguity in the syntax. Side can modify the appendage
    //       or be one of the directions.
    override fun visitJogAppendage(ctx: SpeechSyntaxParser.JogAppendageContext): Any? {
        bottle.type = RequestType.PLACE_END_EFFECTOR
        var direction = sharedDictionary[SharedKey.DIRECTION] as Direction
        sharedDictionary[SharedKey.DIRECTION] = direction

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        var sides = ctx.Side()
        // If direction is specified, then side must be for Appendage.
        if(needsSide(ctx.Appendage().getText())) {
            if( sides.size>0) side = determineSide(sides[0].text, sharedDictionary)
            if (ctx.Direction() != null) direction = determineDirection(ctx.Direction().getText())
            else if(sides.size>1){
                direction = determineDirection(sides[1].text)
            }
        }
        else {
            if (ctx.Direction() != null) direction = determineDirection(ctx.Direction().getText())
            else if(sides.size>0){
                direction = determineDirection(sides[0].text)
            }
        }

        sharedDictionary[SharedKey.SIDE] = side
        var appendage: Appendage = Appendage.NONE
        if (ctx.It() != null) {
            appendage = sharedDictionary[SharedKey.APPENDAGE] as Appendage
        }
        else if (ctx.Appendage() != null) {
            appendage = determineEndEffector(ctx.Appendage().getText(), side)
        }
        if (appendage.equals(Appendage.NONE)) {
            val msg = String.format("I don't have an extremity like that")
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.APPENDAGE] = appendage
            sharedDictionary[SharedKey.IT] = SharedKey.APPENDAGE
            bottle.appendage = appendage
            bottle.text = direction.name
        }
        bottle.values[0] = ctx.Value().getText().toDouble()  // mm
        return null
    }
    // where is your left foot
    override fun visitJointPositionQuestion(ctx: SpeechSyntaxParser.JointPositionQuestionContext): Any? {
        bottle.type = RequestType.GET_EXTREMITY_POSITION
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        if(ctx.Appendage()!=null) {
            val appendage = determineEndEffector(ctx.Appendage().getText(),side)
            bottle.appendage = appendage
            if(appendage.equals(Appendage.NONE)) {
                val msg=String.format("I don't have an end effector %s, that I know of", ctx.Appendage().getText())
                bottle.error=msg
            }
            else {
                bottle.appendage = appendage
                sharedDictionary[SharedKey.APPENDAGE] = appendage
                sharedDictionary[SharedKey.IT]=SharedKey.APPENDAGE
            }
        }
        else {
            val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
            if(joint.equals(Joint.NONE)) {
                val msg=String.format("I don't have a joint %s, that I know of", ctx.Joint().getText())
                bottle.error=msg
            }
            else {
                sharedDictionary[SharedKey.JOINT]=joint
                sharedDictionary[SharedKey.IT]=SharedKey.JOINT
            }
        }
        return null
    }
    // what is the id of your left hip y?
    override fun visitJointPropertyQuestion(ctx: SpeechSyntaxParser.JointPropertyQuestionContext): Any? {
        bottle.type = RequestType.GET_MOTOR_PROPERTY
        val property: String = ctx.Property().getText().lowercase()
        setJointPropertyInMessage(bottle,property)
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have a joint %s, that I know of", ctx.Joint().getText())
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        if (bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE) &&
            bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
            val msg = String.format("I don't have a property %s, that I know of", property)
            bottle.error = msg
        }
        return null
    }


    // ================================== Lists of Things ==================================
    // What actions do you know
    override fun visitListActionNames(ctx: SpeechSyntaxParser.ListActionNamesContext): Any? {
        bottle.type = RequestType.METRIC
        bottle.metric = MetricType.LIST
        bottle.jtype = JsonType.ACTION_NAMES
        return null
    }
    // Who do you know
    override fun visitListFaceNames(ctx: SpeechSyntaxParser.ListFaceNamesContext): Any? {
        bottle.type = RequestType.METRIC
        bottle.metric = MetricType.LIST
        bottle.jtype = JsonType.FACE_NAMES
        return null
    }

    // What are the name of your joints
    override fun visitListBodyParts(ctx: SpeechSyntaxParser.ListBodyPartsContext): Any? {
        determineJsonOrList(visit(ctx.enumerate()).toString(),bottle)
        if( ctx.Appendages()!=null ) bottle.jtype = JsonType.END_EFFECTOR_NAMES
        if( ctx.Motors()!=null  )    bottle.jtype = JsonType.JOINT_NAMES
        if( ctx.Limbs()!=null  )     bottle.jtype = JsonType.LIMB_NAMES
        bottle.metric = MetricType.LIST
        return null
    }

    // List values from the database
    // List your poses
    override fun visitListDatabaseElements(ctx: SpeechSyntaxParser.ListDatabaseElementsContext): Any? {
        determineJsonOrList(visit(ctx.enumerate()).toString(),bottle)
        if( ctx.Faces()!=null )     bottle.jtype = JsonType.FACE_NAMES
        if( ctx.Poses()!=null  )    bottle.jtype = JsonType.POSE_NAMES
        if( ctx.Actions()!=null  )  bottle.jtype = JsonType.ACTION_NAMES
        bottle.metric = MetricType.LIST
        return null
    }

    // what are the limits of your left hip y? (same logic as "handleBulkPropertyQuestion)
    override fun visitListLimits(ctx: SpeechSyntaxParser.ListLimitsContext): Any? {
        determineJsonOrList(visit(ctx.enumerate()).toString(),bottle)
        if (ctx.Limits() != null) bottle.jtype = JsonType.MOTOR_LIMITS
        else                      bottle.jtype = JsonType.MOTOR_GOALS

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        val joint: Joint = determineJoint(ctx.Joint().getText(), axis, side)
        bottle.joint = joint
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have %s joint, that I know of",
                ctx.Joint().getText())
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        return null
    }
    // where are your joints
    override fun visitListPositions(ctx: SpeechSyntaxParser.ListPositionsContext): Any? {
        var txt = "list"
        if(ctx.enumerate()!=null) txt = visit(ctx.enumerate()).toString()
        determineJsonOrList(txt,bottle)
        bottle.jtype = JsonType.JOINT_COORDINATES
        return null
    }
    // Get a list of either static or dynamic motor parameters. The return is in JSON format.
    // List your static motor parameters
    // List the dynamic properties of your motors
    override fun visitListMotorParameters(ctx: SpeechSyntaxParser.ListMotorParametersContext): Any? {
        determineJsonOrList(visit(ctx.enumerate()).toString(),bottle)
        if( ctx.Dynamic()!=null ) bottle.jtype = JsonType.MOTOR_DYNAMIC_PROPERTIES
        if( ctx.Static()!=null  ) bottle.jtype = JsonType.MOTOR_STATIC_PROPERTIES
        bottle.metric = MetricType.LIST
        return null
    }
    // What poses do you know
    override fun visitListPoseNames(ctx: SpeechSyntaxParser.ListPoseNamesContext): Any? {
        bottle.type = RequestType.METRIC
        bottle.metric = MetricType.LIST
        bottle.jtype = JsonType.POSE_NAMES
        return null
    }
    // List a specified property for all joints
    // tell me your motor speeds
    override fun visitListProperty(ctx: SpeechSyntaxParser.ListPropertyContext): Any? {
        determineJsonOrList(visit(ctx.enumerate()).toString(),bottle)
        if (ctx.Properties() != null) {
            val pname: String = ctx.Properties().getText() // plural
            setJointPropertyInMessage(bottle, pname)
            if (!bottle.jointDefinitionProperty.equals(JointDefinitionProperty.NONE)) {
                when (bottle.jointDefinitionProperty) {
                    JointDefinitionProperty.OFFSET        -> bottle.jtype = JsonType.JOINT_OFFSETS
                    JointDefinitionProperty.ORIENTATION   -> bottle.jtype = JsonType.JOINT_ORIENTATIONS
                    JointDefinitionProperty.ID            -> bottle.jtype = JsonType.JOINT_IDS
                    JointDefinitionProperty.MOTORTYPE     -> bottle.jtype = JsonType.JOINT_TYPES
                    else -> {
                        val msg = String.format("we do not support listing %s",pname)
                        bottle.error = msg
                    }
                }
            }
            else if (!bottle.jointDynamicProperty.equals(JointDynamicProperty.NONE)) {
                when (bottle.jointDynamicProperty) {
                    JointDynamicProperty.ANGLE -> bottle.jtype = JsonType.JOINT_ANGLES
                    JointDynamicProperty.SPEED -> bottle.jtype = JsonType.JOINT_SPEEDS
                    JointDynamicProperty.STATE -> bottle.jtype = JsonType.JOINT_STATES
                    JointDynamicProperty.TORQUE -> bottle.jtype = JsonType.JOINT_TORQUES
                    JointDynamicProperty.TEMPERATURE -> bottle.jtype = JsonType.JOINT_TEMPERATURES
                    JointDynamicProperty.VOLTAGE -> bottle.jtype = JsonType.JOINT_VOLTAGES
                    else -> {
                        val msg = String.format("we do not support listing %s",pname)
                        bottle.error = msg
                    }
                }
            }
            else {
                val msg = String.format( "My joints don't hava %s, that I know of", pname.lowercase(Locale.getDefault())
                )
                bottle.error = msg
            }
        }
        else {
            val msg = "you must must specify a motor property like id, angle, or speed"
            bottle.error = msg
        }

        return null
    }

    // =========================================================================================
    // What is your duty cycle? Name, age
    override fun visitMetricsQuestion(ctx: SpeechSyntaxParser.MetricsQuestionContext): Any? {
        bottle.type = RequestType.METRIC
        val metric: String = ctx.Metric().getText().lowercase()
        if( metric.equals("cycles", ignoreCase = true) ||
            metric.equals("cycle count", ignoreCase = true) ) {
            bottle.metric = MetricType.CYCLECOUNT
        }
        else if( metric.equals("cycle time", ignoreCase = true) ) {
            bottle.metric = MetricType.CYCLETIME
        }
        else if( metric.equals("duty cycle", ignoreCase = true) ) {
            bottle.metric = MetricType.DUTYCYCLE
        }
        else {
            bottle.metric = MetricType.fromString(metric)
            if(bottle.metric.equals(MetricType.UNDEFINED)) {
                val msg = String.format("I did't know that I had a %s", metric)
                bottle.error = msg
            }
        }
        return null
    }

    // move your left hip y to 45 degrees
    override fun visitMoveMotor(ctx: SpeechSyntaxParser.MoveMotorContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = Joint.NONE
        if (ctx.It() != null) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        else if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
        }
        if (joint.equals(Joint.NONE)) {
            val msg = String.format("I don't have a joint like that")
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.JOINT] = joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
            bottle.joint = joint
        }
        // Property is fixed as position
        bottle.jointDynamicProperty = JointDynamicProperty.ANGLE
        bottle.values[0] = ctx.Value().getText().toDouble()
        return null
    }


    // Are you there?
    override fun visitPersonalQuestion(ctx: SpeechSyntaxParser.PersonalQuestionContext?): Any? {
        bottle.type = RequestType.NOTIFICATION
        bottle.text = String.format("At your service")
        return null
    }

    // move your left finger to 1000 1000 1000
    override fun visitPlaceAppendage(ctx: SpeechSyntaxParser.PlaceAppendageContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var appendage: Appendage = Appendage.NONE
        if (ctx.It() != null) {
            appendage = sharedDictionary[SharedKey.APPENDAGE] as Appendage
        }
        else if (ctx.Appendage() != null) {
            appendage = determineEndEffector(ctx.Appendage().getText(),side)
        }
        if (appendage.equals(Appendage.NONE)) {
            val msg = String.format("I don't have an end effector like that")
            bottle.error = msg
        }
        else {
            sharedDictionary[SharedKey.APPENDAGE] = appendage
            sharedDictionary[SharedKey.IT] = SharedKey.APPENDAGE
            bottle.appendage = appendage
        }
        // Property is fixed as position
        bottle.values[0] = ctx.Value(0).getText().toDouble()
        bottle.values[1] = ctx.Value(1).getText().toDouble()
        bottle.values[2] = ctx.Value(2).getText().toDouble()
        return null
    }

    // Describe your current pose
    override fun visitPoseDescription(ctx: SpeechSyntaxParser.PoseDescriptionContext): Any? {
        bottle.type = RequestType.JSON
        bottle.jtype= JsonType.POSE_DETAILS
        if (ctx.phrase() != null) {
            val pose: String = visit(ctx.phrase()).toString()
            bottle.arg = pose
        }
        if(ctx.Value() != null ) {
            try {
                bottle.values[0] = ctx.Value().text.toDouble()
            }
            catch(ex:NumberFormatException) {
                bottle.error = "pose index must be an integer"
            }
        }
        else {
            bottle.values[0] = 1.0  // Default index
        }
        return null
    }

    // setMotorProperty is referenced twice in the syntax file, same logic just different order
    // set the position of your left hip y to 45 degrees
    // set the left hip y position to 45 degrees
    // set your left elbow torque to 1.2
    override fun visitSetMotorProperty(ctx: SpeechSyntaxParser.SetMotorPropertyContext): Any? {
       bottle.type = RequestType.SET_MOTOR_PROPERTY
        // Get the property
        setJointPropertyInMessage(bottle,ctx.Property().getText().lowercase())

        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        if (ctx.Joint() != null) {
            bottle.joint = determineJoint(ctx.Joint().getText(), axis, side)
            sharedDictionary[SharedKey.JOINT] = bottle.joint
            sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        }
        else {
            val msg = String.format("I don't have a joint or limb like that")
            bottle.error = msg
        }

        // Value is numerical, "on/off", or speed name - depending on property type
        if (ctx.Value() != null) {
            bottle.values[0] = ctx.Value().getText().toDouble()
        }
        if (ctx.Speed() != null) {
            bottle.text = ctx.Speed().getText()
        }
        else if (ctx.On() != null) {
            bottle.values[0] = ConfigurationConstants.ON_VALUE
        }
        else if (ctx.Off() != null) {
            bottle.values[0] = ConfigurationConstants.OFF_VALUE
        }
        // Sanity check
        if( bottle.joint!=Joint.NONE &&
            bottle.jointDynamicProperty!=JointDynamicProperty.ANGLE &&
            bottle.jointDynamicProperty!=JointDynamicProperty.SPEED &&
            bottle.jointDynamicProperty!=JointDynamicProperty.STATE &&
            bottle.jointDynamicProperty!=JointDynamicProperty.TORQUE  ) {
            bottle.error = "Only angle, speed, torque and state can be set for a joint"
        }
        else if( bottle.joint==Joint.NONE &&
                 bottle.jointDynamicProperty==JointDynamicProperty.ANGLE ) {
            bottle.error = "It doesn't make sense to set all joints to the same angle"
        }
        else if( !bottle.limb.equals(Limb.NONE) && (
                    !bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) &&
                            !bottle.jointDynamicProperty.equals(JointDynamicProperty.TORQUE))) {
            bottle.error = "Speed or torque are the only properties that can be set for an entire limb."
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.ANGLE) && ctx.Value()==null )  {
            bottle.error = "The position must be specified as a numerical value"
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.SPEED) ) {
            if(ctx.Speed()!=null) {
                setSpeedInMessage(bottle,ctx.Speed().toString())
            }
            else if( ctx.Value()==null ) {
                bottle.error = "Speed should be specified as fast, slow, normal, very fast or very slow"
            }
        }
        else if( bottle.jointDynamicProperty.equals(JointDynamicProperty.STATE) ) {
            val value = if(bottle.values.size>0) bottle.values[0] else Double.NaN
            if( value != ConfigurationConstants.ON_VALUE &&
                value != ConfigurationConstants.OFF_VALUE    )   {
                bottle.error = "State must be specified as on or off, enabled or disabled"
            }
        }
        return null
    }


    // Set the speed for all joints to one of the standard choices.
    // now move slowly
    override fun visitSetSpeed(ctx: SpeechSyntaxParser.SetSpeedContext): Any? {
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        bottle.jointDynamicProperty = JointDynamicProperty.SPEED
        setSpeedInMessage(bottle,ctx.Speed().text)
        // Request applies to all joints
        bottle.joint = Joint.NONE
        return null
    }
    // Associate a name with the current facial details. This is not a request.
    // My name is charlie
    override fun visitSetUserName(ctx: SpeechSyntaxParser.SetUserNameContext): Any? {
        bottle.type = RequestType.NONE
        if (ctx.Metric() != null) {
            val metric = ctx.Metric().toString()
            if( metric.equals("name")) {
                if (ctx.phrase() != null) {
                    val phrase: String=visit(ctx.phrase()).toString()
                    FaceMessageHandler.associateNameWithFace(phrase)
                }
            }
            else {
                bottle.error = "I only care about your name"
            }
        }

        return null
    }
    // Stop an action by clearing its follow on
    // Stop 'salute'
    override fun visitStopAction(ctx: SpeechSyntaxParser.StopActionContext): Any? {
        val phrase = ctx.phrase()
        if( phrase!=null ) {
            val act = phrase.text
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.STOP_ACTION
            bottle.arg = act
        }
        else {
            bottle.error = "you must specify an action to stop"
        }
        return null
    }
    // If the joint is not specified, then straighten the entire body
    // straighten your left elbow.
    /* TO-DO Handle limbs */
    override fun visitStraightenJoint(ctx: SpeechSyntaxParser.StraightenJointContext): Any? {
        // A real joint
        bottle.type = RequestType.SET_MOTOR_PROPERTY
        // Get the property
        bottle.jointDynamicProperty = JointDynamicProperty.ANGLE
        // If side or axis were set previously, use those jointValues as defaults
        var side = sharedDictionary[SharedKey.SIDE] as Side
        if (ctx.Side() != null) side = determineSide(ctx.Side().getText(), sharedDictionary)
        sharedDictionary[SharedKey.SIDE] = side
        var axis = sharedDictionary[SharedKey.AXIS] as Axis
        if (ctx.Axis() != null) axis = determineAxis(ctx.Axis().getText())
        sharedDictionary[SharedKey.AXIS] = axis
        var joint: Joint = Joint.NONE
        if (ctx.It() != null && sharedDictionary[SharedKey.IT] == SharedKey.JOINT) {
            joint = sharedDictionary[SharedKey.JOINT] as Joint
        }
        if (ctx.Joint() != null) {
            joint = determineJoint(ctx.Joint().getText(), axis, side)
            bottle.joint = joint
        }

        var value = 0.0
        if( joint==Joint.NONE ) {
            val msg = "what am i supposed to straighten?"
            bottle.error = msg
        }
        else {
            val tree = URDFModel.createJointTree()
            val jp = tree.getJointPositionByName(joint.name)
            value = jp.home
        }

        bottle.joint = joint
        bottle.values[0] = value
        sharedDictionary[SharedKey.JOINT] = joint
        sharedDictionary[SharedKey.IT] = SharedKey.JOINT
        return null
    }

    // why do you wear mittens
    override fun visitWhyMittens(ctx: SpeechSyntaxParser.WhyMittensContext): Any? {
        bottle.type = RequestType.METRIC
        bottle.metric =  MetricType.MITTENS
        return null
    }

    // a phrase. Return space-separated words
    override fun visitWordList(ctx: SpeechSyntaxParser.WordListContext): Any? {
        val text = StringBuffer()
        var needsSpace = false
        for (token in ctx.children) {
            if (token == null) continue
            if (needsSpace) {
                text.append(" ")
            }
            needsSpace = true
            text.append(token.getText())
        }
        return text.toString()
    }

    //===================================== Helper Methods ======================================
    // Determine axis of orientation
    private fun determineAxis(axs: String): Axis {
        val axisName = axs.lowercase()
        var axis = Axis.UNKNOWN

        // Handle some synonyms
        if( axisName.equals("z") || axisName.equals("horizontal")) axis = Axis.Z
        else if( axisName.equals("y") || axisName.equals("vertical") || axis.equals("why")) axis = Axis.Y
        else if( axisName.equals("x") || axisName.equals("ex"))         axis = Axis.X

        return axis
    }
    // Return TRUE if the phrase should be interpreted as one of the fixed commands. If so, update the
    // request bottle appropriately.
    private fun determineCommandFromPhrase(cmd: String): Boolean {
        val phrase = cmd.lowercase()
        var success = true
        if (phrase == "die" || phrase == "exit" || phrase == "halt" || phrase == "quit" ) {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.HALT
        }
        else if (phrase.startsWith("ignore") || phrase.equals("go to sleep",ignoreCase = true) ||
            phrase.startsWith("sleep")) {
            sharedDictionary[SharedKey.ASLEEP] = "true"
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.SLEEP
        }
        else if (phrase.startsWith("pay attention") || phrase.equals("wake up", ignoreCase = true)) {
            sharedDictionary[SharedKey.ASLEEP] = "false"
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.WAKE
        }
        else if (phrase == "power off" || phrase == "shut down" || phrase == "shutdown") {
            bottle.type = RequestType.COMMAND
            bottle.command = CommandType.SHUTDOWN
        }
        else if (phrase.startsWith("straighten")) {
            bottle.type = RequestType.EXECUTE_POSE
            bottle.arg = ConfigurationConstants.POSE_HOME
            bottle.values[0] = ConfigurationConstants.POSE_HOME_INDEX
            sharedDictionary[SharedKey.POSE] = ConfigurationConstants.POSE_HOME
        }
        else {
            success = false
        }
        return success
    }
    // Determine side from the supplied string. If the string is "other", return
    // the side different from the last used. Side is always lower case.
    private fun determineDirection(text: String): Direction {
        var dir = Direction.UNKNOWN
        if (text.equals("back", ignoreCase = true)) dir = Direction.BACK
        else if (text.equals("down", ignoreCase = true)) dir = Direction.DOWN
        else if (text.equals("front", ignoreCase = true)) dir = Direction.FRONT
        else if (text.equals("left", ignoreCase = true)) dir = Direction.LEFT
        else if (text.equals("right", ignoreCase = true)) dir = Direction.RIGHT
        else if (text.equals("up", ignoreCase = true)) dir = Direction.UP
        return dir
    }
    // Determine the specific end effector (appendage) from the body part and side. (Side is not always needed).
    // @param bodyPart - appendage (uppercase)
    private fun determineEndEffector(appendage: String, side: Side): Appendage {
        val bodyPart = appendage.uppercase()
        var result: Appendage = Appendage.NONE
        if (bodyPart.equals("EAR")) {
            result = if(side==Side.LEFT) Appendage.LEFT_EAR else Appendage.RIGHT_EAR
        }
        else if (bodyPart.equals("EYE") || bodyPart.equals("EYES")) {
            result = if(side==Side.LEFT) Appendage.LEFT_EYE else Appendage.RIGHT_EYE
        }
        else if (bodyPart.equals("FINGER") || bodyPart.equals("HAND")) {
            result = if(side==Side.LEFT) Appendage.LEFT_FINGER else Appendage.RIGHT_FINGER
        }
        else if (bodyPart.equals("FOOT") || bodyPart.equals("TOE")) {
            result = if(side==Side.LEFT) Appendage.LEFT_TOE else Appendage.RIGHT_TOE
        }
        else if (bodyPart.equals("HEEL")) {
            result = if(side==Side.LEFT) Appendage.LEFT_HEEL else Appendage.RIGHT_HEEL
        }
        else if (bodyPart.equals("NOSE")) {
            result = Appendage.NOSE
        }
        if( result==Appendage.NONE ) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineEndEffector did not find a match for %s",
                    bodyPart ))
        }
        return result
    }
    // Set the request type for an enumeration
    private fun determineJsonOrList(text: String, msg: MessageBottle) {
        if (text.equals("download", ignoreCase = true))  {
            msg.type = RequestType.JSON
        }
        else {
            msg.type = RequestType.METRIC
            msg.metric = MetricType.LIST
        }
    }
    // Determine the specific joint from the body part, side and axis. (The latter two are
    // not always needed). Side always lower case.
    private fun determineJoint(part: String, axis: Axis, side: Side): Joint {
        val bodyPart = part.uppercase()
        var result: Joint = Joint.NONE

        if (bodyPart.equals("ABS") || bodyPart.equals("ABDOMEN") ) {
                result = if(axis==Axis.X)       Joint.ABS_X
                         else if(axis==Axis.Y)  Joint.ABS_Y
                         else                   Joint.ABS_Z
        }
        else if (bodyPart.equals("ANKLE")) {
                result = if(side==Side.LEFT) Joint.LEFT_ANKLE_Y else Joint.RIGHT_ANKLE_Y
        }
        else if (bodyPart.equals("BUST") || bodyPart.equals("CHEST")) {
                result = if(axis==Axis.X) Joint.CHEST_X else Joint.CHEST_Y
        }
        else if( bodyPart.equals("IMU") ) {
            result = Joint.IMU
        }
        else if (bodyPart.equals("ELBOW")) {
            result = if(side==Side.LEFT) Joint.LEFT_ELBOW_Y else Joint.RIGHT_ELBOW_Y
        }
        else if (bodyPart.equals("NECK")) {
            result = if(axis==Axis.Y) Joint.NECK_Y else Joint.NECK_Z
        }
        else if (bodyPart.equals("HIP") || bodyPart.equals("THIGH")) {
                if(side==Side.LEFT) {
                    result = if(axis==Axis.X)      Joint.LEFT_HIP_X
                             else if(axis==Axis.Y) Joint.LEFT_HIP_Y
                             else                  Joint.LEFT_HIP_Z
                }
                else if(side==Side.RIGHT) {
                    result = if (axis.equals("x"))     Joint.RIGHT_HIP_X
                            else if (axis.equals("y")) Joint.RIGHT_HIP_Y
                            else Joint.RIGHT_HIP_Z
                }
        }
        else if (bodyPart.equals("KNEE")) {
                result = if (side.equals("left")) Joint.LEFT_KNEE_Y else Joint.RIGHT_KNEE_Y
        }
        else if (bodyPart.equals("SHOULDER") || bodyPart.equals("ARM")) {
                if (side==Side.LEFT) {
                    result = if(axis==Axis.X)      Joint.LEFT_SHOULDER_X
                             else if(axis==Axis.Y) Joint.LEFT_SHOULDER_Y
                             else                  Joint.LEFT_SHOULDER_Z
                }
                else if(side==Side.RIGHT) {
                    result = if(axis==Axis.X)      Joint.RIGHT_SHOULDER_X
                             else if(axis==Axis.Y) Joint.RIGHT_SHOULDER_Y
                             else                  Joint.RIGHT_SHOULDER_Z
                }
        }
        if(result==Joint.NONE) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineJoint did not find a match for %s",
                    bodyPart))
        }
        return result
    }

    // Determine the specific limb from the body part and side. Side is not always needed,
    // but is alswys lower case.
    // A limb is a grouping of joints, e.g. "ARM" includes elbow and shoulder.
    private fun determineLimb(body: String, side: Side): Limb {
        val bodyPart = body.uppercase()
        var result: Limb = Limb.NONE
        if (bodyPart.equals("ARM")) {
                result = if(side==Side.LEFT) Limb.LEFT_ARM else Limb.RIGHT_ARM
        }
        else if (bodyPart.equals("LEG")) {
                result = if(side==Side.LEFT) Limb.LEFT_LEG else Limb.RIGHT_LEG
        }
        else if (bodyPart.equals("BACK") || bodyPart.equals("TORSO")) {
            result = Limb.TORSO
        }
        else if (bodyPart.equals("HEAD")) {
            result = Limb.HEAD
        }
        if( result==Limb.NONE ) {
            LOGGER.info(String.format("WARNING: StatementTranslator.determineLimb did not find a match for %s",
                    bodyPart))
        }
        return result
    }

    // Determine side from the supplied string. If the string is "other", return
    // the side different from the last used. Side is always lower case.
    private fun determineSide(text: String, dict: MutableMap<SharedKey, Any>): Side {
        var side = Side.RIGHT
        if (text.equals("left", ignoreCase = true)) side = Side.LEFT
        else if (text.equals("other", ignoreCase = true)) {
            val former = dict[SharedKey.SIDE]
            side = if(former==Side.LEFT) Side.RIGHT else Side.LEFT
        }
        return side
    }
    //@return true if the textual name of the end-effector refers to an Appendage
    // that needs a side specification.
    // @param appendage - appendage (uppercase)
    private fun needsSide(text: String?): Boolean {
        var needs = false
        if( text!=null) {
            val appendageText = text.uppercase()
            if( appendageText.equals("EAR")  ||
                appendageText.equals("EYE") ||
                appendageText.equals("FINGER") ||
                appendageText.equals("HAND") ||
                appendageText.equals("FOOT") ||
                appendageText.equals("TOE")||
                appendageText.equals("HEEL")  ) {
                needs = true
            }
        }
        return needs
    }
    // The poses returned here are expected to exist in the Pose table of the database.
    // Canonical names are: very slow speed,slow speed,normal speed,fast speed,very fast speed
    private fun poseForAdverb(adverb: String): String {
        val speed = adverb.lowercase()
        val currentSpeed = sharedDictionary[SharedKey.SPEED].toString()
        if(speed.contains("faster") ||
            speed.contains("quicker")) {
            if(currentSpeed.equals("very slow speed")) sharedDictionary[SharedKey.SPEED] = "slow speed"
            else if(currentSpeed.equals("slow speed")) sharedDictionary[SharedKey.SPEED] = "normal speed"
            else if(currentSpeed.equals("normal speed")) sharedDictionary[SharedKey.SPEED] = "fast speed"
            else if(currentSpeed.equals("fast speed")) sharedDictionary[SharedKey.SPEED] = "very fast speed"
        }
        else if (speed.contains("slower")) {
            if(currentSpeed.equals("very fast speed")) sharedDictionary[SharedKey.SPEED] = "fast speed"
            else if(currentSpeed.equals("fast speed")) sharedDictionary[SharedKey.SPEED] = "normal speed"
            else if(currentSpeed.equals("normal speed")) sharedDictionary[SharedKey.SPEED] = "slow speed"
            else if(currentSpeed.equals("slow speed")) sharedDictionary[SharedKey.SPEED] = "very slow speed"
        }
        else if (speed.contains("slow motion")) {
            sharedDictionary[SharedKey.SPEED] = "very slow speed"
        }
        else if(speed.contains("slow")) {
            if(speed.contains("very")) {
                sharedDictionary[SharedKey.SPEED] = "very slow speed"
            }
            else {
                sharedDictionary[SharedKey.SPEED] = "slow speed"
            }
        }
        else if(speed.contains("fast") ||
                speed.contains("quick")) {
            if(speed.contains("very")) {
                sharedDictionary[SharedKey.SPEED] = "very fast speed"
            }
            else {
                sharedDictionary[SharedKey.SPEED] = "fast speed"
            }
        }
        else if(speed.contains("normal")) {
            sharedDictionary[SharedKey.SPEED] = "normal speed"
        }
        return sharedDictionary[SharedKey.SPEED].toString()   // Must be a pose name
    }

    // Determine a joint property from the supplied string. It may be either a static
    // or dynamic property. Take care of recognized aliases. The name may be plural
    // in some settings. Set the appropriate property in the supplied message.
    private fun setJointPropertyInMessage(msg: MessageBottle, name: String) {
        var pname = name
        if (pname.endsWith("s") || pname.endsWith("S")) {
            pname = pname.substring(0, pname.length - 1).uppercase(Locale.getDefault())
        }
        var isDynamic = true
        if (pname.equals("angle", ignoreCase = true))              pname = "ANGLE"
        else if (pname.equals("position", ignoreCase = true ))     pname = "ANGLE"
        else if (pname.equals("load", ignoreCase = true ))         pname = "LOAD"
        else if (pname.equals("max angle", ignoreCase = true))     pname ="MAXIMUMANGLE"
        else if (pname.equals("min angle", ignoreCase = true))     pname ="MINIMUMANGLE"
        else if (pname.equals("maximum angle", ignoreCase = true)) pname ="MAXIMUMANGLE"
        else if (pname.equals("minimum angle", ignoreCase = true)) pname ="MINIMUMANGLE"
        else if (pname.equals("motor type", ignoreCase = true))    pname ="MOTORTYPE"
        else if (pname.equals("range", ignoreCase = true))         pname ="RANGE"
        else if (pname.equals("max speed", ignoreCase = true))    pname ="MAXIMUMSPEED"
        else if (pname.equals("maximum speed", ignoreCase = true))pname ="MAXIMUMSPEED"
        else if (pname.equals("speed", ignoreCase = true))         pname ="SPEED"
        else if (pname.equals("state", ignoreCase = true))         pname = "STATE"
        else if (pname.equals("temp", ignoreCase = true))          pname = "TEMPERATURE"
        else if (pname.equals("temperature", ignoreCase = true))   pname = "TEMPERATURE"
        else if (pname.equals("max torque", ignoreCase = true))    pname ="MAXIMUMTORQUE"
        else if (pname.equals("maximum torque", ignoreCase = true))pname ="MAXIMUMTORQUE"
        else if (pname.equals("torque", ignoreCase = true))        pname = "TORQUE"
        else if (pname.equals("velocity", ignoreCase = true))      pname = "SPEED"
        else if (pname.equals("velocitie", ignoreCase = true))     pname = "SPEED"
        else if (pname.equals("voltage", ignoreCase = true))       pname = "VOLTAGE"
        else {
            isDynamic = false
        }

        if (pname.equals("id", ignoreCase = true))               pname = "ID"
        else if (pname.equals("motor type", ignoreCase = true))  pname = "MOTORTYPE"
        else if (pname.equals("offset", ignoreCase = true))      pname = "OFFSET"
        else if (pname.equals("orientation", ignoreCase = true)) pname = "ORIENTATION"

        if( isDynamic ) msg.jointDynamicProperty = JointDynamicProperty.fromString(pname)
        else            msg.jointDefinitionProperty = JointDefinitionProperty.fromString(pname)

    }
    // If speed is specified as a word, then convert to a numeric value
    // If this applies to all joints, then speed is a fraction of max,
    // else it is the actual speed
    private fun setSpeedInMessage(msg: MessageBottle, speed: String) {
        if(speed.contains("slow")) {
            if(speed.contains("very")) {msg.values[0] = (if(msg.joint==Joint.NONE) 0.25 else 0.25*ConfigurationConstants.TOP_SPEED)}
            else                             {msg.values[0] = (if(msg.joint==Joint.NONE) 0.10 else 0.8*ConfigurationConstants.TOP_SPEED)}
        }
        else if(speed.contains("fast") ||
            speed.contains("quick")) {
            if(speed.contains("very")) {msg.values[0] = (if(msg.joint==Joint.NONE) 1.0 else 1.0*ConfigurationConstants.TOP_SPEED)}
            else                             {msg.values[0] = (if(msg.joint==Joint.NONE) 0.8 else 0.8*ConfigurationConstants.TOP_SPEED)}
        }
        else                                 {msg.values[0] = (if(msg.joint==Joint.NONE) 0.5 else 0.5*ConfigurationConstants.TOP_SPEED)}   // normal
    }

    private val CLSS = "StatementTranslator"
    private val LOGGER = Logger.getLogger(CLSS)
    private val DEBUG: Boolean

    /**
     */
    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_COMMAND)
        bottle = bot
        messageTranslator = MessageTranslator()
    }
}