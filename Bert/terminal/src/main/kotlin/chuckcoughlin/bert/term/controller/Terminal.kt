/**
 * Copyright 2022-2023. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.term.controller

import chuckcoughlin.bert.common.controller.Controller
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.message.CommandType
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.message.RequestType
import chuckcoughlin.bert.common.model.ConfigurationConstants
import chuckcoughlin.bert.common.model.RobotModel
import chuckcoughlin.bert.speech.process.MessageTranslator
import chuckcoughlin.bert.speech.process.StatementParser
import chuckcoughlin.bert.sql.db.Database
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.selects.select
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.*
import java.util.logging.Logger

/**
 * "Terminal" handles direct interaction from the user to command and
 * interrogate the robot. Typed entries are the same as given to the "Command"
 * controller in spoken form. Requests originate from stdIn and responses
 * sent to stdOut.
 *
 * @param parent - the dispatcher
 * @param req - channel for dispatcher requests as generated by the user
 * @param rsp - channel for responses from the parent (Dispatcher)
 */
class Terminal(parent: Controller,req: Channel<MessageBottle>,rsp: Channel<MessageBottle>) : Controller {
    private val parser: StatementParser
    private val translator: MessageTranslator
    private val dispatcher = parent
    private var requestChannel  = req    // Dispatcher->Terminal  (dispatcher results)
    private var responseChannel = rsp    // Terminal->Dispatcher  (user requests)
    private var prompt:String

    private val scope = MainScope() // Uses Dispatchers.Main
    private var ignoring : Boolean
    private var running:Boolean

    /**
     * While running, this controller processes messages between the Dispatcher
     * and a user terminal. A few messages are intercepted that cause a
     * quick shutdown. These are direct responses to user input, like "shutdown".
     */
    override suspend fun start() {
        if( !running ) {
            running = true
            val br = BufferedReader(InputStreamReader(System.`in`))
            runBlocking<Unit> {
                launch {Dispatchers.IO
                    while(running) {
                        select<Unit> {
                            /**
                             * These are responses coming from the Dispatcher
                             * Simply display them.
                             */
                            responseChannel.onReceive() {
                                displayMessage(it)   // stdOut
                            }
                            /**
                             * Read from stdin, blocked. Use ANTLR to convert text into requests.
                             * Forward requests to the dispatcher.
                             */
                            async {
                                handleUserInput(br)
                            }
                        }
                    }
                }
            }
        }
        else {
            LOGGER.warning(String.format("%s: attempted to start, but already running...", CLSS))
        }
    }

    override suspend fun stop() {
        if( running ) {
            scope.cancel()
            Database.shutdown()
            LOGGER.warning(String.format("%s: exiting...", CLSS))
            running = false
            System.exit(0)
        }
    }

    /**
     * The message is expected to carry understandable text, an error
     * message or a value that can be formatted into user-ready text.
     * Send directly to stdOut
     * @param response
     */
    fun displayMessage(msg: MessageBottle) {
        val text: String = translator.messageToText(msg)
        println(text)
        print(prompt)
    }
    /**
     * Read directly from stdin.
     * Convert the text into a MessageBottle and forward
     * it to the dispatcher.
     */
    suspend fun handleUserInput(br:BufferedReader) {
        val input = br.readLine()
        if( input!=null) {
            val text = input
            System.out.println(prompt)
            if( text.isNotEmpty() ) {
                LOGGER.info(String.format("%s:parsing %s", CLSS, text))
                val request = parser.parseStatement(text)
                if( request.error.isNotEmpty() ||
                    request.type.equals(RequestType.NOTIFICATION) ) {
                    displayMessage(request)   // Take care of locally to stdOut
                }
                else if(isLocalRequest(request)) {
                    val msg = handleLocalRequest(request)
                    requestChannel.send(msg)
                }
                else {
                    requestChannel.send(request)
                }
            }
        }
    }

    // We handle the command to sleep and awake immediately.
    private fun handleLocalRequest(request: MessageBottle): MessageBottle {
        if (request.type==RequestType.COMMAND) {
            val command: CommandType = request.command
            //LOGGER.warning(String.format("%s.handleLocalRequest: command=%s",CLSS,command));
            if( command.equals(CommandType.SLEEP) ){
                ignoring = true
            }
            else if( command.equals(CommandType.WAKE)) {
                ignoring = false
            }
            else {
                val msg = String.format("I don't recognize command %s", command)
                request.error = msg
            }
        }
        request.text = translator.randomAcknowledgement()
        return request
    }

    // We handle the command to sleep and awake immediately.
    private fun isLocalRequest(request: MessageBottle): Boolean {
        var isLocal = false
        if (request.type==RequestType.COMMAND) {
            val command: CommandType = request.command
            //LOGGER.warning(String.format("%s.handleLocalRequest: command=%s",CLSS,command));
            if( command.equals(CommandType.SLEEP) ||
                command.equals(CommandType.WAKE)) {
                isLocal = true
            }
        }
        return isLocal
    }

    private val CLSS = "Terminal"
    private val LOGGER = Logger.getLogger(CLSS)
    private val PROMPT = "Bert:"    // Default prompt
    override val controllerName = CLSS
    override val controllerType = ControllerType.TERMINAL

    init {
        parser = StatementParser()
        translator = MessageTranslator()
        prompt = RobotModel.getPropertyForController(controllerType,ConfigurationConstants.PROPERTY_PROMPT,PROMPT)
        running = false
        ignoring = false
    }
}