/**
 * Copyright 2022-2023. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.term.controller

import chuckcoughlin.bert.common.controller.Controller
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.message.BottleConstants
import chuckcoughlin.bert.common.message.CommandType
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.message.RequestType
import chuckcoughlin.bert.common.model.ConfigurationConstants
import chuckcoughlin.bert.common.model.RobotModel
import chuckcoughlin.bert.speech.process.MessageTranslator
import chuckcoughlin.bert.speech.process.StatementParser
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.selects.select
import java.util.logging.Logger

/**
 * "Terminal" handles direct interaction from the user to command and
 * interrogate the robot. Typed entries are the same as given to the "Command"
 * controller in spoken form. Requests originate from stdIn and responses
 * sent to stdOut.
 *
 * @param parent - the dispatcher
 * @param stdin - channel for requests generated by the user
 * @param stdout - channel for responses from the dispatcher to be displayed
 */
class Terminal(parent: Controller,stdin: Channel<MessageBottle>,stdout: Channel<MessageBottle>) : Controller {
    private val parser: StatementParser
    private val translator: MessageTranslator
    private var stdinChannel = stdin    // Terminal->Dispatcher  (user requests)
    private var stdoutChannel = stdout  // Dispatcher->Terminal  (dispatcher response for display)
    private var prompt: String

    @DelicateCoroutinesApi
    private val scope = GlobalScope // For long-running coroutines
    private var ignoring: Boolean
    private var running: Boolean
    private var job: Job

    /**
     * While running, this controller processes messages between the Dispatcher
     * and a user terminal. A few messages are intercepted that totally local
     * in nature (SLEEP,WAKE).
     *
     * A response to a request that started here will have the source as Termonal.
     *
     * When run autonomously (like as a system service), the terminal is not used.
     */
    @DelicateCoroutinesApi
    override suspend fun execute(): Unit = coroutineScope {
        if (!running) {
            LOGGER.info(String.format("%s.execute: started...", CLSS))
            running = true
            /* select() in coroutine to balance sends/receives from DIspatcher */
            job = scope.launch(Dispatchers.IO) {
                while (running) {
                    if (DEBUG) LOGGER.info(String.format("%s.execute waiting for select", CLSS))
                    print(prompt)
                    select<MessageBottle> {
                        stdoutChannel.onReceive() { it ->
                            displayMessage(it)
                            it
                        }
                        handleUserInput().onAwait{it}
                    } // End select
                    if (DEBUG) LOGGER.info(String.format("%s.execute select completed", CLSS))
                }
            }
        }
        else {
            LOGGER.warning(String.format("%s.execute: attempted to start, but already running...", CLSS))
        }
    }


    override suspend fun shutdown() {
        if (running) {
            running = false
            job.cancel()
        }
    }

    /**
     * The message is expected to carry understandable text, an error
     * message or a value that can be formatted into user-ready text.
     * Send directly to stdOut
     * @param response
     */
    fun displayMessage(msg: MessageBottle) {
        val text: String = translator.messageToText(msg)
        println(text)
    }

    /**
     * Read from stdin, blocked. Use ANTLR to convert text into a message bottle.
     * async returns  a deferred value.
     */
    fun handleUserInput(): Deferred<MessageBottle> =
        GlobalScope.async(Dispatchers.IO) {
            var request = MessageBottle(RequestType.NONE)
            val text = readln()
            if (DEBUG) LOGGER.info(String.format("%s.handleUserInput:returning %s", CLSS, text))
            if (text.isNotEmpty()) {
                request = parser.parseStatement(text)
                request.source = controllerName
                if (DEBUG) LOGGER.info(String.format("%s.handleUserInput:parsed %s", CLSS, text))
            }
            if (!request.error.equals(BottleConstants.NO_ERROR)) {
                if (DEBUG) LOGGER.info(
                    String.format("%s.execute ERROR = %s (%s)", CLSS, request.error, request.text))
                displayMessage(request)   // Show the error
                print(prompt)           // Prompt for new input
            }
            else if (isLocalRequest(request)) {
                val m = handleLocalRequest(request)
                if (DEBUG) LOGGER.info(String.format("%s.execute  local = %s", CLSS, m.text))
            }
            else if (request.type.equals(RequestType.NOTIFICATION)) {
                if (DEBUG) LOGGER.info(
                    String.format("%s.execute notification = %s", CLSS, request.text)
                )
                displayMessage(request)   // Write local notification to stdout
                print(prompt)
            }
            else {
                stdinChannel.send(request)
                if (DEBUG) LOGGER.info(
                    String.format("%s.execute request sent to dispatcher", CLSS)
                )
            }
            request
        }

    // We handle the command to sleep and awake immediately.
    private fun handleLocalRequest(request: MessageBottle): MessageBottle {
        if(DEBUG) LOGGER.info(String.format("%s.handleLocalRequest:%s",CLSS,request.text));
        if (request.type==RequestType.COMMAND) {
            val command: CommandType = request.command
            LOGGER.info(String.format("%s.handleLocalRequest: command=%s",CLSS,command));
            if( command.equals(CommandType.SLEEP) ){
                ignoring = true
            }
            else if( command.equals(CommandType.WAKE)) {
                ignoring = false
            }
            else {
                val msg = String.format("I don't recognize command %s", command)
                request.error = msg
            }
        }
        request.text = translator.randomAcknowledgement()
        return request
    }

    // We handle the command to sleep and awake immediately.
    private fun isLocalRequest(request: MessageBottle): Boolean {
        var isLocal = false
        val command: CommandType = request.command
        if (request.type==RequestType.COMMAND) {
            if( command.equals(CommandType.SLEEP) ||
                command.equals(CommandType.WAKE)) {
                isLocal = true
            }
        }
        LOGGER.info(String.format("%s.isLocalRequest: command=%s (%s)",CLSS,command,
            if(isLocal)"true" else "false"))
        return isLocal
    }

    private val CLSS = "Terminal"
    private val LOGGER = Logger.getLogger(CLSS)
    private val DEBUG: Boolean
    private val PROMPT = "Bert:"    // Default prompt
    override val controllerName = CLSS
    override val controllerType = ControllerType.TERMINAL

    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_TERMINAL)
        parser = StatementParser()
        translator = MessageTranslator()
        prompt = RobotModel.getPropertyForController(controllerType,ConfigurationConstants.PROPERTY_PROMPT,PROMPT)
        running  = false
        ignoring = false
        job = Job()
    }
}