/**
 * Copyright 2022-2023. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.dispatch
import chuckcoughlin.bert.common.controller.Controller
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.message.RequestType
import chuckcoughlin.bert.common.model.Limb
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import java.util.logging.Logger

/**
 * A timer controller accepts a RequestBottle and submits it to the parent
 * Dispatcher on a clocked basis.
 */
class InternalController(parent : Dispatcher,req: Channel<MessageBottle>,rsp: Channel<MessageBottle>) : Controller {
    private val dispatcher = parent
    private var toDispatcher   = req    // Internal->Dispatcher  (dispatcher gets results)
    private var fromDispatcher = rsp    // Dispatcher->Internal
    private val timedQueue: TimedQueue
    private val sequentialQueues: MutableMap<Limb, SequentialQueue>
    private val scope = MainScope() // Uses Dispatchers.Main
    private var running:Boolean
    private var index:Long          // Sequence of a message
    private var job:Job

    override suspend fun execute() {
        if (!running) {
            LOGGER.info(String.format("%s.execute: started...", CLSS))
            running = true
            /* Coroutine to accept requests from the Dispatcher
             */
            scope.launch(Dispatchers.IO) {
                while (running) {
                    val msg = fromDispatcher.receive()
                    if (DEBUG) LOGGER.info(String.format("%s.execute received: %s", CLSS, msg.text))
                    handleRequest(msg)
                }
            }
            /*
             * Coroutine to process the next request from the queues. Whenever a new message
             * is added to the timer queue, the job is cancelled to allow re-sorting of the
             * message by start time.
             */
            job = scope.launch(Dispatchers.IO) {
                while (running) {
                    try {
                            if (DEBUG) LOGGER.info(String.format("%s.execute : evaluating queues...", CLSS))
                            evaluateQueues()         // Are there any new messages in the sequential queues
                            val readyMessage = timedQueue.removeNextReady()  // Returns after delay time
                            dispatchMessage(readyMessage)
                    }
                    catch (cex: CancellationException) {
                        if (DEBUG) LOGGER.info(String.format("%s.execute: cancelled evaluation ", CLSS))
                    }
                }
            }
        }
        else {
            LOGGER.warning(String.format("%s.execute: attempted to start, but already running...", CLSS))
        }
    }

    override suspend fun shutdown() {
        if( running ) {
            timedQueue.stop()
            job.cancelAndJoin()
            running = false
        }
    }

    /*
     * Check the sequential queues for any that have messages ready to process.
     * Place any ready messages onto the timed queue.
     */
    private fun evaluateQueues() {
        for (sq: SequentialQueue in sequentialQueues.values) {
            if (sq.locked == false && sq.isNotEmpty()) {
                val msg = sq.removeFirst()
                sendToTimerQueue(msg)
            }
        }
    }
    /**
     * All requests to the InternalController are generated by the dispatcher or dispatcher's solver.
     * This class determines how we handle them. If there is no limb specified
     * then the message is placed on the NONE limb and from there directly to the timer queue.
     * @param request incoming message holder
     */
    private suspend fun handleRequest(msg: MessageBottle) {
        // A SYNC message simply unlocks the work queue
        if(msg.type.equals(RequestType.SYNC)) {
            sequentialQueues[msg.limb]!!.locked = false
        }
        // New request to add to the queue
        else {
            val now = System.currentTimeMillis()
            msg.control.executionTime = now + msg.control.delay
            msg.control.id = index
            index = index++
            val limb = msg.limb
            var queue: SequentialQueue? = sequentialQueues[limb]
            if (queue != null) {
                if (DEBUG) LOGGER.info(String.format("%s.handleRequest %s on %s (%s)", CLSS, msg.type.name,
                            limb.name, if (queue.locked) "IN PROGRESS" else "IDLE"))
                queue.addLast(msg)
            }
            else {
                    LOGGER.severe(String.format("%s.handleRequest No queue for limb", CLSS, limb.name))
            }
        }
        evaluateQueues()
        //job.cancelAndJoin()  // No need.
    }


    /**
     * Called by the timer queue once the message is ready to execute. Forward to the
     * dispatcher for actual processing. Mark the source as INTERNAL so
     * that the dispatcher knows to return the message here once processing is complete.
     * @param holder
     */
    suspend fun dispatchMessage(message:MessageBottle) {
        message.source = ControllerType.INTERNAL.name
        toDispatcher.send(message)
    }

    /**
     * As far as the sequential queue is concerned, a message is pending
     * from the time it is placed on the timer queue until it returns
     * as a response from the Dispatcher
     * @param queue queue from which the message originated.
     * @param holder container for the message to be sent
     */
    private fun sendToTimerQueue( msg: MessageBottle) {
        msg.control.executionTime = System.currentTimeMillis()
        timedQueue.addMessage(msg)
    }

    private val CLSS = "InternalController"
    private val DEBUG = true
    private val LOGGER = Logger.getLogger(CLSS)
    override val controllerName = CLSS
    override val controllerType = ControllerType.INTERNAL

    init {
        running = false
        index = 0
        job = Job()
        timedQueue = TimedQueue(this)
        sequentialQueues = HashMap<Limb,SequentialQueue>()
        // Create a queue for each limb
        for(limb in Limb.values()) {
            sequentialQueues[limb] = SequentialQueue()
        }
    }
}