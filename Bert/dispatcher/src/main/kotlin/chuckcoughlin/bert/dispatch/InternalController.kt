/**
 * Copyright 2022-2023. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.dispatch
import chuckcoughlin.bert.common.controller.Controller
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.model.JointDefinitionProperty
import chuckcoughlin.bert.control.model.QueueName
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.selects.select
import java.util.logging.Logger

/**
 * A timer controller accepts a RequestBottle and submits it to the parent
 * Dispatcher on a clocked basis. The initial implementation handles only a
 * single request.
 */
class InternalController(parent : Dispatcher,req: Channel<MessageBottle>,rsp: Channel<MessageBottle>) : Controller {
    private val dispatcher = parent
    private var requestChannel  = req    // Dispatcher->internal
    private var responseChannel = rsp    // internal->Dispatcher  (dispatcher gets results)
    private val timedQueue: TimedQueue
    private val sequentialQueues: MutableMap<QueueName, SequentialQueue>
    private val pendingMessages: MutableMap<Long, InternalMessageHolder>
    private val scope = MainScope() // Uses Dispatchers.Main
    private var running:Boolean
    private var index:Long          // Sequence of a message

    override suspend fun execute() {
        if( !running ) {
            timedQueue.start()
            running = true
            runBlocking<Unit> {
                launch {
                    Dispatchers.IO
                    while (running) {
                        select<Unit> {
                            /**
                             * These are requests coming from the dispatcher
                             */
                            requestChannel.onReceive() {
                            }
                            /**
                             * Forward responses to the dispatcher.
                             */
                            async {

                            }
                        }
                    }
                }
            }
        }
    }

    override fun shutdown() {
        if( running ) {
            timedQueue.stop()
            running = false
        }
    }

    /**
     * All requests to the InternalController are generated by the dispatcher or dispatcher's solver.
     * This class determines how we handle them. If there is no queue specified
     * then the message is placed directly on the timer queue.
     * @param request incoming message holder
     */
    /**
     * All requests to the InternalController are generated by the dispatcher or dispatcher's solver.
     * This class determines how we handle them. If there is no queue specified
     * then the message is placed directly on the timer queue.
     * @param request incoming message holder
     */
    fun receiveRequest(holder: InternalMessageHolder) {
        val now = System.nanoTime() / 1000000
        holder.executionTime = now + holder.delay
        holder.id = index
        index = index++
        val qn: QueueName = holder.queue
        var queue: SequentialQueue? = sequentialQueues[qn]
        if (queue != null) {
            LOGGER.info(
                String.format("%s.receiveRequest %s on %s (%s)", CLSS, holder.message.type,
                    holder.queue.name, if (queue.inProgress) "IN PROGRESS" else "IDLE"
                )
            )
            queue.addLast(holder)
            if (!queue.inProgress) {
                val newholder = queue.removeFirst()
                queue.inProgress = true
                sendToTimerQueue(queue, newholder) // Just in case there's a required delay
            }
        }
        else {
            sendToTimerQueue(null, holder)
        }
    }

    /**
     * The dispatcher has received a response to one of our requests and has
     * forwarded it here. Possible dispositions:
     * 1) If message was from a queue, then we trigger processing of the next message on the queue, if any
     * 2) If the message was marked for repeating, then place it on the timer queue
     * 3) Discard the message,
     */
    /**
     * The dispatcher has received a response to one of our requests and has
     * forwarded it here. Possible dispositions:
     * 1) If message was from a queue, then we trigger processing of the next message on the queue, if any
     * 2) If the message was marked for repeating, then place it on the timer queue
     * 3) Discard the message,
     */
    suspend fun receiveResponse(msg: MessageBottle) {
        var holder: InternalMessageHolder? = pendingMessages[index]
        if (holder != null) {
            pendingMessages.remove(index)
            // Reinstate the original source in the message so the dispatcher can route appropriately
            holder.reinstateOriginalSource()

            //LOGGER.info(String.format("%s.receiveResponse(%d) %s",CLSS,holder.getMessage().getId(),
            //		holder.getMessage().fetchRequestType().name()));
            val qn: QueueName = holder.queue
            var queue: SequentialQueue? = sequentialQueues[qn]
            if (queue != null) {
                if (queue.isEmpty()) {
                    LOGGER.info(String.format("%s.receiveResponse(%d) %s on %s (empty)",
                        CLSS, JointDefinitionProperty.ID,holder.message.type.name, qn.name))
                    queue.inProgress = false
                }
                else {
                    queue.inProgress = true
                    LOGGER.info(String.format("%s.receiveResponse(%d) %s on %s (%d queued)",
                        CLSS, JointDefinitionProperty.ID,holder.message.type.name, qn.name, queue.size))
                    holder = queue.removeFirst()
                    sendToTimerQueue(queue, holder) // Just in case there's a required delay
                }
            }
            else {
                if (holder.shouldRepeat) {
                    val now = System.nanoTime() / 1000000 // Work in milliseconds
                    holder.executionTime = (now + holder.repeatInterval)
                    sendToTimerQueue(null, holder)
                }
            }
            responseChannel.send(msg) // Will reply to the original source
        }
        else {
            LOGGER.info(
                String.format("%s.receiveResponse(%d) %s: not on pending queue for %s",
                    CLSS,index,msg.type.name,msg.source))
        }
    }

    /**
     * Called by the timer queue once the message is ready to execute. Forward to the
     * dispatcher for actual processing. Mark the source as INTERNAL so
     * that the dispatcher knows to return the message here once processing is complete.
     * @param holder
     */
    /**
     * Called by the timer queue once the message is ready to execute. Forward to the
     * dispatcher for actual processing. Mark the source as INTERNAL so
     * that the dispatcher knows to return the message here once processing is complete.
     * @param holder
     */
    suspend fun dispatchMessage(holder: InternalMessageHolder) {
        holder.message.source = ControllerType.INTERNAL.name
        responseChannel.send(holder.message)
    }



    /**
     * As far as the sequential queue is concerned, a message is pending
     * from the time it is placed on the timer queue until it returns
     * as a response from the Dispatcher
     * @param queue queue from which the message originated.
     * @param holder container for the message to be sent
     */
    /**
     * As far as the sequential queue is concerned, a message is pending
     * from the time it is placed on the timer queue until it returns
     * as a response from the Dispatcher
     * @param queue queue from which the message originated.
     * @param holder container for the message to be sent
     */
    private fun sendToTimerQueue(queue: SequentialQueue?, holder: InternalMessageHolder) {
        if (queue != null) {
            pendingMessages[index] = holder
            // LOGGER.info(String.format("%s.sendToTimerQueue: %d from %s",CLSS,holder.getMessage().getId(),holder.getQueue().name()));
            queue.inProgress = true
        }
        timedQueue.addMessage(holder)
    }

    private val CLSS = "InternalController"
    private val LOGGER = Logger.getLogger(CLSS)
    override val controllerName = CLSS
    override val controllerType = ControllerType.INTERNAL

    init {
        running = false
        index = 0
        timedQueue = TimedQueue(this)
        sequentialQueues = HashMap()
        pendingMessages = HashMap<Long, InternalMessageHolder>()
        sequentialQueues[QueueName.GLOBAL] = SequentialQueue()
        sequentialQueues[QueueName.HEAD] = SequentialQueue()
        sequentialQueues[QueueName.LEFT_ARM] = SequentialQueue()
        sequentialQueues[QueueName.LEFT_LEG] = SequentialQueue()
        sequentialQueues[QueueName.RIGHT_ARM] = SequentialQueue()
        sequentialQueues[QueueName.RIGHT_LEG] = SequentialQueue()
    }
}