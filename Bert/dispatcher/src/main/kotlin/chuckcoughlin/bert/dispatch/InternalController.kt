/**
 * Copyright 2022-2024. Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.dispatch
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.controller.MessageController
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.message.RequestType
import chuckcoughlin.bert.common.model.ConfigurationConstants
import chuckcoughlin.bert.common.model.Joint
import chuckcoughlin.bert.common.model.Limb
import chuckcoughlin.bert.common.model.MotorConfiguration
import chuckcoughlin.bert.common.model.RobotModel
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import java.util.HashMap
import java.util.logging.Logger

/**
 * The internal controller is used to implement delays in messages destined for the
 * motor controllers. The delays are both configured and designed to prevent commands
 * being sent too quickly. All messages are returned to the Dispatcher (which then
 * distributes them to the intended targets).
 *
 * In the future this controller will be used to delay movements that interfere with
 * other movements in progress, or stop movements that may cause collisions between
 * separate appendages.
 *
 * Messages are executed in the order they are received.
 */
@DelicateCoroutinesApi
class InternalController(req: Channel<MessageBottle>,rsp: Channel<MessageBottle>) :
                                                        MessageController {
    private val scope = GlobalScope     // For long-running coroutines
    private var toDispatcher   = req    // Internal->Dispatcher  (dispatcher gets results)
    private var fromDispatcher = rsp    // Dispatcher->Internal
    private var running:Boolean
    private var index:Long          // Sequence of a message
    private var job:Job
    private val queues : MutableMap<Limb,SequentialQueue>
    @DelicateCoroutinesApi
    override suspend fun execute() {
        if (!running) {
            LOGGER.info(String.format("%s.execute: started...", CLSS))
            running = true
            /* Coroutine to accept requests from the Dispatcher.
             * Requests are processed in the order they are received.
             */
            job = scope.launch(Dispatchers.IO) {
                LOGGER.info(String.format("%s.execute: launched...", CLSS))
                while (running) {
                    val msg = fromDispatcher.receive()
                    if (DEBUG) {
                        if(msg.type== RequestType.COMMAND)
                            LOGGER.info(String.format("%s.execute received: %s %s", CLSS, msg.type.name,msg.command.name))
                        else
                            LOGGER.info(String.format("%s.execute received: %s", CLSS, msg.type.name))
                    }
                    handleRequest(msg)
                }
            }
        }
        else {
            LOGGER.warning(String.format("%s.execute: attempted to start, but already running...", CLSS))
        }
    }

    override suspend fun shutdown() {
        if (DEBUG) println(String.format("%s.shutdown: shutting down ... ", CLSS))
        if( running ) {
            running = false
            job.cancel()
            if (DEBUG) println(String.format("%s.shutdown: cancelled job ", CLSS))
            for( queue in queues.values ) {
                queue.shutdown()
            }
        }
    }

    /**
     * All requests to the InternalController are generated by the dispatcher or dispatcher's solver.
     * This class determines how we handle them. If there is no limb specified
     * then the message is placed on the NONE limb and from there directly to the timer queue.
     * @param request incoming message holder
     */
    private suspend fun handleRequest(msg: MessageBottle) {
        val now = System.currentTimeMillis()
        var delayTime = LATENCY + msg.control.delay
        if (!msg.joint.equals(Joint.NONE)) {
            val mc = RobotModel.motorsByJoint.get(msg.joint)!!
            val required = mc.commandTime + mc.travelTime - now
            if (required > delayTime) delayTime = required
        }
        val jvWalker = msg.getJointValueIterator()
        while (jvWalker.hasNext()) {
            val jv = jvWalker.next()
            val mc = RobotModel.motorsByJoint.get(jv.joint)!!
            val required = mc.commandTime + mc.travelTime - now
            if (required > delayTime) delayTime = required
        }
        delay(delayTime)
        // Run in background
        GlobalScope.launch {
            dispatchMessage(msg)
        }
    }


    /**
     * Forward to the dispatcher for actual processing (presumeably by the MotorController).
     * Retain the source as the original source of the message. This allows the dispatcher to
     * forward the response to the proper requestor.
     * @param msg
     */
    override suspend fun dispatchMessage(msg:MessageBottle) {
        if (DEBUG) LOGGER.info(String.format("%s.dispatchMessage sending to dispatcher: %s ", CLSS, msg.type.name))
        // Mark dispatch time on motors
        val now = System.currentTimeMillis()
        if( !msg.joint.equals(Joint.NONE) ) RobotModel.motorsByJoint.get(msg.joint)!!.commandTime = now
        val jvWalker = msg.getJointValueIterator()
        while( jvWalker.hasNext() ) {
            val jv = jvWalker.next()
            RobotModel.motorsByJoint.get(jv.joint)!!.commandTime = now
        }
        val queue = queues[msg.limb]!!
        queue.addLast(msg)
    }
    private fun initializeQueues() {
        for( limb in Limb.values() ) {
            val queue = SequentialQueue(limb,toDispatcher,configurationsForLimb(limb))
            queues[limb] = queue
        }
    }
    private fun configurationsForLimb(limb: Limb): Map<Joint,MotorConfiguration> {
        val map: MutableMap<Joint,MotorConfiguration> = mutableMapOf<Joint,MotorConfiguration>()
        for (joint in RobotModel.motorsByJoint.keys) {
            val mc = RobotModel.motorsByJoint[joint]!!
            if (mc.limb.equals(limb) || limb.equals(Limb.NONE)) {
                map[joint]=mc
            }
        }
        return map
    }

    private val CLSS = "InternalController"
    private val DEBUG : Boolean
    private val LATENCY = 100L     // Estimated time between dispatch here and receipt by motor
    private val LOGGER = Logger.getLogger(CLSS)
    override val controllerName = CLSS
    override val controllerType = ControllerType.INTERNAL

    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_INTERNAL)
        running = false
        index = 0
        job = Job() // Parent job
        queues = mutableMapOf<Limb,SequentialQueue>()
        initializeQueues()
    }
}