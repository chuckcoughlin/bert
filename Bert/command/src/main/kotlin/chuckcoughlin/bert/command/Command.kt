/**
 * Copyright 2022-2024 Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.command

import chuckcoughlin.bert.common.controller.Controller
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.message.BottleConstants
import chuckcoughlin.bert.common.message.CommandType
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.message.MessageType
import chuckcoughlin.bert.common.message.RequestType
import chuckcoughlin.bert.common.model.ConfigurationConstants
import chuckcoughlin.bert.common.model.RobotModel
import chuckcoughlin.bert.speech.process.MessageTranslator
import chuckcoughlin.bert.speech.process.StatementParser
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.selects.select
import java.awt.SystemColor.text
import java.net.ServerSocket
import java.util.logging.Logger

/**
 * This is the class that handles spoken commands and forwards
 * them on to the central dispatcher. It also handles database actions
 * involving playback and record.
 *
 * This class routes requests/responses between the Dispatcher and a TCP network (wifi).
 * Communication with the Dispatcher is via Kotlin channels and communication with
 * the network is via a TCP socket.
 *
 * If there is no network connection configured, this class is not called
 * by the dispatcher.
 *
 * @param req - channel for dispatcher requests as generated by the user
 * @param rsp - channel for responses from the parent (Dispatcher)
 */
class Command(req : Channel<MessageBottle>,rsp: Channel<MessageBottle>) :Controller {
    private val host:String
    private val port:Int
    private val translator: MessageTranslator
    private val parser: StatementParser
    private var requestChannel=req     // Command->Dispatcher  (requests initiated by user)
    private var responseChannel=rsp    // Dispatcher->Command  (results of user requests)

    @DelicateCoroutinesApi
    private val scope=GlobalScope // For long-running coroutines
    private var ignoring: Boolean
    private var running: Boolean
    private var suppressingErrors: Boolean
    private var job: Job
    var startMessage = "Starting ..."

    /**
     * While running, read from the network (i.e. the tablet) and forward
     * resulting requests to the dispatcher. We accept its responses and forward back to the tablet.
     * Communication with the tablet consists of simple strings, plus a 4-character header.
     *
     * A few messages are intercepted that cause a quick shutdown. These are direct responses
     * to user input, like "shutdown".
     */
    @DelicateCoroutinesApi
    override suspend fun execute(): Unit=coroutineScope {
        if(!running) {
            LOGGER.info(String.format("%s.execute: started...", CLSS))
            running = true
            /* There should be a start message in the channel - but instead this hangs */
            //val startmsg = responseChannel.receive()
            //startMessage = startmsg.text

            /* First connect to the network (always LOCALHOST) */
            try {
                val serverSocket = ServerSocket(port)
                LOGGER.info(String.format("%s.execute: server socket created on %s (%d)", CLSS,
                    serverSocket.inetAddress.canonicalHostName, serverSocket.localPort))

                /* We can connect with multiple clients, but only one at a time */
                job = scope.launch(Dispatchers.IO) {
                    while (running) {
                        LOGGER.info(String.format("%s.execute: waiting to accept client connection ...", CLSS))
                        try {
                            val socket = serverSocket.accept()
                            LOGGER.info(String.format("%s.execute: accepted client socket %s (%d)", CLSS,
                                socket.inetAddress.canonicalHostName, socket.port))
                            var connected = true
                            val handler = SocketMessageHandler(socket!!)
                            sendStartupMessage(handler)
                            while (connected) {
                                select<Unit> {
                                    /** Receive from the Dispatcher */
                                    responseChannel.onReceive() {
                                        if (!it.type.equals(RequestType.NOTIFICATION) &&  // Ignore notifications
                                            !it.type.equals(RequestType.NONE)) {          // Ignore type NONE
                                            connected = handler.sendResponse(it)
                                        }
                                    }
                                    /**
                                     * Read from the tablet via the network. Use ANTLR to convert text into requests.
                                     * Forward requests to the Dispatcher launcher.
                                     */
                                    handler.receiveNetworkInput().onAwait() {
                                        if (it != null && it.isNotEmpty()) {
                                            val msg = processRequest(it)
                                            LOGGER.info(String.format("%s.execute: received from socket (%s)", CLSS,msg.type.name))
                                            // Ignore non-commands/requests
                                            if( !msg.type.equals(RequestType.NONE) &&
                                                !msg.type.equals(RequestType.NOTIFICATION) ) {
                                                if(isLocalRequest(msg)) {
                                                    handleLocalRequest(msg)
                                                }
                                                else {
                                                    LOGGER.info(String.format("%s.execute: sending to dispatcher (%s)", CLSS,msg.type.name))
                                                    requestChannel.send(msg)
                                                }
                                            }
                                        }
                                        else {
                                            connected = false
                                        }
                                    }
                                }
                            }
                            LOGGER.info(String.format("%s.execute: select complete - wait for new connection", CLSS))
                            if (!socket.isClosed) socket.close()
                        }
                        catch(ex:Exception ) {
                            LOGGER.warning(String.format("%s: Error accepting client connection (%s)", CLSS,port,ex.localizedMessage))
                            delay(DELAY)
                        }
                        delay(DELAY)
                    }
                    // No longer running
                    serverSocket.close()
                }
                LOGGER.info(String.format("%s.execute: Complete ", CLSS))
            }
            catch( ex:Exception ) {
                LOGGER.warning(String.format("%s: Error creating socket server, localhost port %d (%s)", CLSS,port,ex.localizedMessage))
                running = false
            }
        }
        else {
            LOGGER.warning(String.format("%s: attempted to start, but already running...", CLSS))
        }
    }

    override suspend fun shutdown() {
        if(running) {
            running=false
            job.cancel()
        }
    }

    /**
     * Analyze text and use ANTLR to convert into a MessageBottle
     * Send to the dispatcher unless this can be handled locally
     *
     * There are only two kinds of messages (MSG,JSN) that result in actions. Anything
     * else is simply logged. Returning an empty string signals loss of the client.
     * Throw an exception to force closing of the socket.
     */
    private fun processRequest(txt:String) : MessageBottle {
        var msg = MessageBottle(RequestType.NONE)

        if (txt.length > BottleConstants.HEADER_LENGTH) {
            val hdr  = txt.substring(0, BottleConstants.HEADER_LENGTH - 1)
            val text = txt.substring(BottleConstants.HEADER_LENGTH)
            if( DEBUG ) LOGGER.info(String.format("TABLET READ: %s:%s.", hdr,text))
            if (hdr.equals(MessageType.MSG.name, ignoreCase = true)) {
                // We've stripped the header now analyze the rest.
                try {
                    if(DEBUG) LOGGER.info(String.format(" parsing %s: %s", hdr,text))
                    msg = parser.parseStatement(text)
                    if(DEBUG) LOGGER.info(String.format(" returned %s: %s (%s)", msg.type.name,msg.text,msg.error))
                }
                catch (ex: Exception) {
                    msg = MessageBottle(RequestType.NOTIFICATION)
                    msg.error = String.format("Parse failure (%s) on: %s", ex.localizedMessage, msg.type.name)
                }
            }
            else if (hdr.equals(MessageType.JSN.name, ignoreCase = true)) {
                LOGGER.info(String.format(" parsing JSN: %s", text))
                msg.error = String.format("JSON messages are not recognized from the tablet")
            }
            // For now simply log responses from the tablet.
            else if (hdr.equals(MessageType.ANS.name, ignoreCase = true)) {
                LOGGER.info(String.format("Tablet ANS: %s",text))
                msg = parser.parseStatement(text)
            }
            // Simply send tablet log messages to our logger
            else if (hdr.equals(MessageType.LOG.name, ignoreCase = true)) {
                LOGGER.info(String.format("Tablet LOG: %s",text))
            }
            else {
                msg = MessageBottle(RequestType.NOTIFICATION)
                msg.error = String.format("Message has an unrecognized prefix (%s)", hdr)
            }
        }
        else {
            msg = MessageBottle(RequestType.NOTIFICATION)
            msg.error = String.format("Received a short message from the tablet (%s)", text)
        }
        msg.source = ControllerType.COMMAND.name
        if( msg.type == RequestType.NONE ) { // NONE simply doesn't get processed
            if (msg.type == RequestType.NOTIFICATION ||
                msg.type == RequestType.PARTIAL ||
                !msg.error.equals(BottleConstants.NO_ERROR)) {

                suppressingErrors = true // Suppress replies to consecutive syntax errors
                val text: String = translator.messageToText(msg)
                LOGGER.info(String.format("%s.SuppressedErrorMessage: %s", CLSS, text))
            }
            else {
                suppressingErrors = false
            }
        }
        return msg
    }


    // We handle the command to sleep and awake immediately.
    private fun handleLocalRequest(request: MessageBottle): MessageBottle {
        if(request.type.equals(RequestType.COMMAND)) {
            val command: CommandType =request.command
            LOGGER.warning(String.format("%s.handleLocalRequest: command=%s", CLSS, command))
            if(command.equals(CommandType.SLEEP)) {
                ignoring=true
            }
            else if(command.equals(CommandType.WAKE)) {
                ignoring=false
            }
            else {
                val msg=String.format("I don't recognize command %s", command)
                request.error=msg
            }
        }
        request.text=translator.randomAcknowledgement()
        return request
    }
    // Local requests are those that can be handled immediately without forwarding to the dispatcher.
    private fun isLocalRequest(request: MessageBottle): Boolean {
        if (request.type.equals(RequestType.COMMAND)) {
            val cmd = request.command
            if (cmd == CommandType.SLEEP || cmd == CommandType.WAKE) {
                return true
            }
        }
        return false
    }

    /** Send a startup message directly to the socket **/
    fun sendStartupMessage(handler:SocketMessageHandler) {
        val text = String.format("%s:%s",MessageType.ANS.name,startMessage)
        handler.sendText(text)
    }

    private val CLSS = "Command"
    private val DELAY = 2000L
    private val DEBUG: Boolean
    private val LOGGER = Logger.getLogger(CLSS)
    private val LOCALHOST = "127.0.0.1"
    override val controllerName = CLSS
    override val controllerType = ControllerType.COMMAND

    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_COMMAND)
        ignoring = false
        running = false
        suppressingErrors = false
        parser = StatementParser()
        translator = MessageTranslator()
        host = LOCALHOST
        port = RobotModel.getPropertyForController(controllerType, ConfigurationConstants.PROPERTY_PORT).toInt()
        LOGGER.info(String.format("%s.init: %s on %s",CLSS,host,port))
        job = Job()
    }
}
