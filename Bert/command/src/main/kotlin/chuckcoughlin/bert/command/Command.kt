/**
 * Copyright 2022-2024 Charles Coughlin. All Rights Reserved.
 * MIT License.
 */
package chuckcoughlin.bert.command

import chuckcoughlin.bert.common.controller.Controller
import chuckcoughlin.bert.common.controller.ControllerType
import chuckcoughlin.bert.common.controller.NamedSocket
import chuckcoughlin.bert.common.message.CommandType
import chuckcoughlin.bert.common.message.MessageBottle
import chuckcoughlin.bert.common.message.RequestType
import chuckcoughlin.bert.common.model.ConfigurationConstants
import chuckcoughlin.bert.common.model.RobotModel
import chuckcoughlin.bert.speech.process.MessageTranslator
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import java.util.logging.Logger

/**
 * This is the class that handles spoken commands and forwards
 * them on to the central dispatcher. It also handles database actions
 * involving playback and record.
 *
 * This class routes requests/responses between the Dispatcher and "blueserverd" daemon.
 * Communication with the Dispatcher is via Kotlin channels and communication with
 * Bluetooth is via a socket.
 *
 * If there is no Bluetooth configured, the class does nothing.
 *
 * @param parent - the dispatcher
 * @param req - channel for dispatcher requests as generated by the user
 * @param rsp - channel for responses from the parent (Dispatcher)
 */
class Command(parent: Controller,req : Channel<MessageBottle>,rsp: Channel<MessageBottle>) :Controller {
    private var tabletSocket: BluetoothSocket
    private val messageTranslator: MessageTranslator
    private val dispatcher = parent
    private var requestChannel  = req    // Dispatcher->Command  (results of user requests)
    private var responseChannel = rsp    // Command->Dispatcher  (requests initiated by user)
    @DelicateCoroutinesApi
    private val scope = GlobalScope // For long-running coroutines
    private var ignoring : Boolean
    private var running:Boolean
    private var inJob:Job
    private var outJob:Job

    /**
     * While running, read from the bluetooth daemon (representing the tablet) and forward
     * resulting requests to the dispatcher. We accept its responses and forward back to the tablet.
     * Communication with the tablet consists of simple strings, plus a 4-character header.
     *
     * A few messages are intercepted that cause a quick shutdown. These are direct responses
     * to user input, like "shutdown".
     */
    @DelicateCoroutinesApi
    override suspend fun execute() {
        if( !running ) {
            LOGGER.info(String.format("%s.execute: started...", CLSS))
            running = true
            /* Coroutine to write responses from the Dispatcher to tablet
             * via Bluetooth, that is the Bluetooth socket
             */
            outJob = scope.launch(Dispatchers.IO) {
                while (running) {
                    val msg = responseChannel.receive()
                    if (DEBUG) LOGGER.info(
                        (String.format(
                            "%s.execute: received %s",
                            CLSS, msg.type.name
                        ))
                    )
                    if (msg.type != RequestType.NOTIFICATION) {  // Ignore notifications
                        tabletSocket.receiveResponse(msg)
                    }
                }
                /**
                 * Read from bluetooth. Use ANTLR to convert text into requests.
                 * Forward requests to the Dispatcher launcher.
                 */
                inJob = scope.launch(Dispatchers.IO) {
                    val msg = tabletSocket.receiveRequest()
                    if (DEBUG) LOGGER.info(
                        (String.format(
                            "%s.execute: received %s",
                            CLSS, msg.type.name
                        ))
                    )
                    if (isLocalRequest(msg)) {
                        handleLocalRequest(msg)
                    } else {
                        requestChannel.send(msg)
                    }
                }
            }
        }
        else {
            LOGGER.warning(String.format("%s: attempted to start, but already running...", CLSS))
        }
    }

    override suspend fun shutdown() {
        if( running ) {
            running = false
            inJob.cancel()
            outJob.cancel()
        }
    }

    // We handle the command to sleep and awake immediately.
    private fun handleLocalRequest(request: MessageBottle): MessageBottle {
        if (request.type.equals(RequestType.COMMAND)) {
            val command: CommandType = request.command
            LOGGER.warning(String.format("%s.handleLocalRequest: command=%s", CLSS, command))
            if( command.equals(CommandType.SLEEP) ) {
                ignoring = true
            }
            else if( command.equals(CommandType.WAKE) ) {
                ignoring = false
            }
            else {
                val msg = String.format("I don't recognize command %s", command)
                request.error = msg
            }
        }
        request.text = messageTranslator.randomAcknowledgement()
        return request
    }

    // Local requests are those that can be handled immediately without forwarding to the dispatcher.
    private fun isLocalRequest(request: MessageBottle): Boolean {
        if (request.type.equals(RequestType.COMMAND)) {
            val cmd = request.command
            if (cmd == CommandType.SLEEP || cmd == CommandType.WAKE) {
                return true
            }
        }
        return false
    }

    private val CLSS = "Command"
    private val DEBUG: Boolean
    private val LOGGER = Logger.getLogger(CLSS)
    private val EXIT_WAIT_INTERVAL: Long = 1000
    override val controllerName = CLSS
    override val controllerType = ControllerType.COMMAND

    init {
        DEBUG = RobotModel.debug.contains(ConfigurationConstants.DEBUG_COMMAND)
        ignoring = false
        running = false
        messageTranslator = MessageTranslator()
        val socketName = RobotModel.getPropertyForController(controllerType, ConfigurationConstants.PROPERTY_SOCKET)
        LOGGER.info(String.format("%s.init: %s %s=%s", CLSS, controllerName,ConfigurationConstants.PROPERTY_SOCKET,socketName))
        val port = RobotModel.getPropertyForController(controllerType, ConfigurationConstants.PROPERTY_PORT)
        LOGGER.info(String.format("%s.init: %s %s=%s", CLSS, controllerName,ConfigurationConstants.PROPERTY_PORT,port))
        val socket = NamedSocket(socketName,port.toInt())
        tabletSocket = BluetoothSocket(socket)
        inJob = Job()
        outJob = Job()
    }
}